/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit https://github.com/brianpetro/obsidian-smart-templates
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../jsbrains/smart-templates/ejs.min.cjs
var require_ejs_min = __commonJS({
  "../jsbrains/smart-templates/ejs.min.cjs"(exports2, module2) {
    (function(f) {
      if (typeof exports2 === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.ejs = f();
      }
    })(function() {
      var define2, module3, exports3;
      return (/* @__PURE__ */ function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof require && require;
                if (!f && c) return c(i2, true);
                if (u) return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
          return o;
        }
        return r;
      }())({ 1: [function(require2, module4, exports4) {
        "use strict";
        var fs = require2("fs");
        var path = require2("path");
        var utils = require2("./utils");
        var scopeOptionWarned = false;
        var _VERSION_STRING = require2("../package.json").version;
        var _DEFAULT_OPEN_DELIMITER = "<";
        var _DEFAULT_CLOSE_DELIMITER = ">";
        var _DEFAULT_DELIMITER = "%";
        var _DEFAULT_LOCALS_NAME = "locals";
        var _NAME = "ejs";
        var _REGEX_STRING = "(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)";
        var _OPTS_PASSABLE_WITH_DATA = ["delimiter", "scope", "context", "debug", "compileDebug", "client", "_with", "rmWhitespace", "strict", "filename", "async"];
        var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat("cache");
        var _BOM = /^\uFEFF/;
        var _JS_IDENTIFIER = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
        exports4.cache = utils.cache;
        exports4.fileLoader = fs.readFileSync;
        exports4.localsName = _DEFAULT_LOCALS_NAME;
        exports4.promiseImpl = new Function("return this;")().Promise;
        exports4.resolveInclude = function(name, filename, isDir) {
          var dirname = path.dirname;
          var extname = path.extname;
          var resolve = path.resolve;
          var includePath = resolve(isDir ? filename : dirname(filename), name);
          var ext = extname(name);
          if (!ext) {
            includePath += ".ejs";
          }
          return includePath;
        };
        function resolvePaths(name, paths) {
          var filePath;
          if (paths.some(function(v) {
            filePath = exports4.resolveInclude(name, v, true);
            return fs.existsSync(filePath);
          })) {
            return filePath;
          }
        }
        function getIncludePath(path2, options) {
          var includePath;
          var filePath;
          var views = options.views;
          var match = /^[A-Za-z]+:\\|^\//.exec(path2);
          if (match && match.length) {
            path2 = path2.replace(/^\/*/, "");
            if (Array.isArray(options.root)) {
              includePath = resolvePaths(path2, options.root);
            } else {
              includePath = exports4.resolveInclude(path2, options.root || "/", true);
            }
          } else {
            if (options.filename) {
              filePath = exports4.resolveInclude(path2, options.filename);
              if (fs.existsSync(filePath)) {
                includePath = filePath;
              }
            }
            if (!includePath && Array.isArray(views)) {
              includePath = resolvePaths(path2, views);
            }
            if (!includePath && typeof options.includer !== "function") {
              throw new Error('Could not find the include file "' + options.escapeFunction(path2) + '"');
            }
          }
          return includePath;
        }
        function handleCache(options, template) {
          var func;
          var filename = options.filename;
          var hasTemplate = arguments.length > 1;
          if (options.cache) {
            if (!filename) {
              throw new Error("cache option requires a filename");
            }
            func = exports4.cache.get(filename);
            if (func) {
              return func;
            }
            if (!hasTemplate) {
              template = fileLoader(filename).toString().replace(_BOM, "");
            }
          } else if (!hasTemplate) {
            if (!filename) {
              throw new Error("Internal EJS error: no file name or template provided");
            }
            template = fileLoader(filename).toString().replace(_BOM, "");
          }
          func = exports4.compile(template, options);
          if (options.cache) {
            exports4.cache.set(filename, func);
          }
          return func;
        }
        function tryHandleCache(options, data, cb) {
          var result;
          if (!cb) {
            if (typeof exports4.promiseImpl == "function") {
              return new exports4.promiseImpl(function(resolve, reject) {
                try {
                  result = handleCache(options)(data);
                  resolve(result);
                } catch (err) {
                  reject(err);
                }
              });
            } else {
              throw new Error("Please provide a callback function");
            }
          } else {
            try {
              result = handleCache(options)(data);
            } catch (err) {
              return cb(err);
            }
            cb(null, result);
          }
        }
        function fileLoader(filePath) {
          return exports4.fileLoader(filePath);
        }
        function includeFile(path2, options) {
          var opts = utils.shallowCopy(utils.createNullProtoObjWherePossible(), options);
          opts.filename = getIncludePath(path2, opts);
          if (typeof options.includer === "function") {
            var includerResult = options.includer(path2, opts.filename);
            if (includerResult) {
              if (includerResult.filename) {
                opts.filename = includerResult.filename;
              }
              if (includerResult.template) {
                return handleCache(opts, includerResult.template);
              }
            }
          }
          return handleCache(opts);
        }
        function rethrow(err, str, flnm, lineno, esc) {
          var lines = str.split("\n");
          var start = Math.max(lineno - 3, 0);
          var end = Math.min(lines.length, lineno + 3);
          var filename = esc(flnm);
          var context = lines.slice(start, end).map(function(line, i) {
            var curr = i + start + 1;
            return (curr == lineno ? " >> " : "    ") + curr + "| " + line;
          }).join("\n");
          err.path = filename;
          err.message = (filename || "ejs") + ":" + lineno + "\n" + context + "\n\n" + err.message;
          throw err;
        }
        function stripSemi(str) {
          return str.replace(/;(\s*$)/, "$1");
        }
        exports4.compile = function compile(template, opts) {
          var templ;
          if (opts && opts.scope) {
            if (!scopeOptionWarned) {
              console.warn("`scope` option is deprecated and will be removed in EJS 3");
              scopeOptionWarned = true;
            }
            if (!opts.context) {
              opts.context = opts.scope;
            }
            delete opts.scope;
          }
          templ = new Template(template, opts);
          return templ.compile();
        };
        exports4.render = function(template, d, o) {
          var data = d || utils.createNullProtoObjWherePossible();
          var opts = o || utils.createNullProtoObjWherePossible();
          if (arguments.length == 2) {
            utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);
          }
          return handleCache(opts, template)(data);
        };
        exports4.renderFile = function() {
          var args = Array.prototype.slice.call(arguments);
          var filename = args.shift();
          var cb;
          var opts = { filename };
          var data;
          var viewOpts;
          if (typeof arguments[arguments.length - 1] == "function") {
            cb = args.pop();
          }
          if (args.length) {
            data = args.shift();
            if (args.length) {
              utils.shallowCopy(opts, args.pop());
            } else {
              if (data.settings) {
                if (data.settings.views) {
                  opts.views = data.settings.views;
                }
                if (data.settings["view cache"]) {
                  opts.cache = true;
                }
                viewOpts = data.settings["view options"];
                if (viewOpts) {
                  utils.shallowCopy(opts, viewOpts);
                }
              }
              utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
            }
            opts.filename = filename;
          } else {
            data = utils.createNullProtoObjWherePossible();
          }
          return tryHandleCache(opts, data, cb);
        };
        exports4.Template = Template;
        exports4.clearCache = function() {
          exports4.cache.reset();
        };
        function Template(text, opts) {
          opts = opts || utils.createNullProtoObjWherePossible();
          var options = utils.createNullProtoObjWherePossible();
          this.templateText = text;
          this.mode = null;
          this.truncate = false;
          this.currentLine = 1;
          this.source = "";
          options.client = opts.client || false;
          options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;
          options.compileDebug = opts.compileDebug !== false;
          options.debug = !!opts.debug;
          options.filename = opts.filename;
          options.openDelimiter = opts.openDelimiter || exports4.openDelimiter || _DEFAULT_OPEN_DELIMITER;
          options.closeDelimiter = opts.closeDelimiter || exports4.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
          options.delimiter = opts.delimiter || exports4.delimiter || _DEFAULT_DELIMITER;
          options.strict = opts.strict || false;
          options.context = opts.context;
          options.cache = opts.cache || false;
          options.rmWhitespace = opts.rmWhitespace;
          options.root = opts.root;
          options.includer = opts.includer;
          options.outputFunctionName = opts.outputFunctionName;
          options.localsName = opts.localsName || exports4.localsName || _DEFAULT_LOCALS_NAME;
          options.views = opts.views;
          options.async = opts.async;
          options.destructuredLocals = opts.destructuredLocals;
          options.legacyInclude = typeof opts.legacyInclude != "undefined" ? !!opts.legacyInclude : true;
          if (options.strict) {
            options._with = false;
          } else {
            options._with = typeof opts._with != "undefined" ? opts._with : true;
          }
          this.opts = options;
          this.regex = this.createRegex();
        }
        Template.modes = { EVAL: "eval", ESCAPED: "escaped", RAW: "raw", COMMENT: "comment", LITERAL: "literal" };
        Template.prototype = { createRegex: function() {
          var str = _REGEX_STRING;
          var delim = utils.escapeRegExpChars(this.opts.delimiter);
          var open = utils.escapeRegExpChars(this.opts.openDelimiter);
          var close = utils.escapeRegExpChars(this.opts.closeDelimiter);
          str = str.replace(/%/g, delim).replace(/</g, open).replace(/>/g, close);
          return new RegExp(str);
        }, compile: function() {
          var src;
          var fn;
          var opts = this.opts;
          var prepended = "";
          var appended = "";
          var escapeFn = opts.escapeFunction;
          var ctor;
          var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : "undefined";
          if (!this.source) {
            this.generateSource();
            prepended += '  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n';
            if (opts.outputFunctionName) {
              if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) {
                throw new Error("outputFunctionName is not a valid JS identifier.");
              }
              prepended += "  var " + opts.outputFunctionName + " = __append;\n";
            }
            if (opts.localsName && !_JS_IDENTIFIER.test(opts.localsName)) {
              throw new Error("localsName is not a valid JS identifier.");
            }
            if (opts.destructuredLocals && opts.destructuredLocals.length) {
              var destructuring = "  var __locals = (" + opts.localsName + " || {}),\n";
              for (var i = 0; i < opts.destructuredLocals.length; i++) {
                var name = opts.destructuredLocals[i];
                if (!_JS_IDENTIFIER.test(name)) {
                  throw new Error("destructuredLocals[" + i + "] is not a valid JS identifier.");
                }
                if (i > 0) {
                  destructuring += ",\n  ";
                }
                destructuring += name + " = __locals." + name;
              }
              prepended += destructuring + ";\n";
            }
            if (opts._with !== false) {
              prepended += "  with (" + opts.localsName + " || {}) {\n";
              appended += "  }\n";
            }
            appended += "  return __output;\n";
            this.source = prepended + this.source + appended;
          }
          if (opts.compileDebug) {
            src = "var __line = 1\n  , __lines = " + JSON.stringify(this.templateText) + "\n  , __filename = " + sanitizedFilename + ";\ntry {\n" + this.source + "} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n";
          } else {
            src = this.source;
          }
          if (opts.client) {
            src = "escapeFn = escapeFn || " + escapeFn.toString() + ";\n" + src;
            if (opts.compileDebug) {
              src = "rethrow = rethrow || " + rethrow.toString() + ";\n" + src;
            }
          }
          if (opts.strict) {
            src = '"use strict";\n' + src;
          }
          if (opts.debug) {
            console.log(src);
          }
          if (opts.compileDebug && opts.filename) {
            src = src + "\n//# sourceURL=" + sanitizedFilename + "\n";
          }
          try {
            if (opts.async) {
              try {
                ctor = new Function("return (async function(){}).constructor;")();
              } catch (e) {
                if (e instanceof SyntaxError) {
                  throw new Error("This environment does not support async/await");
                } else {
                  throw e;
                }
              }
            } else {
              ctor = Function;
            }
            fn = new ctor(opts.localsName + ", escapeFn, include, rethrow", src);
          } catch (e) {
            if (e instanceof SyntaxError) {
              if (opts.filename) {
                e.message += " in " + opts.filename;
              }
              e.message += " while compiling ejs\n\n";
              e.message += "If the above error is not helpful, you may want to try EJS-Lint:\n";
              e.message += "https://github.com/RyanZim/EJS-Lint";
              if (!opts.async) {
                e.message += "\n";
                e.message += "Or, if you meant to create an async function, pass `async: true` as an option.";
              }
            }
            throw e;
          }
          var returnedFn = opts.client ? fn : function anonymous(data) {
            var include = function(path2, includeData) {
              var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data);
              if (includeData) {
                d = utils.shallowCopy(d, includeData);
              }
              return includeFile(path2, opts)(d);
            };
            return fn.apply(opts.context, [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]);
          };
          if (opts.filename && typeof Object.defineProperty === "function") {
            var filename = opts.filename;
            var basename = path.basename(filename, path.extname(filename));
            try {
              Object.defineProperty(returnedFn, "name", { value: basename, writable: false, enumerable: false, configurable: true });
            } catch (e) {
            }
          }
          return returnedFn;
        }, generateSource: function() {
          var opts = this.opts;
          if (opts.rmWhitespace) {
            this.templateText = this.templateText.replace(/[\r\n]+/g, "\n").replace(/^\s+|\s+$/gm, "");
          }
          this.templateText = this.templateText.replace(/[ \t]*<%_/gm, "<%_").replace(/_%>[ \t]*/gm, "_%>");
          var self2 = this;
          var matches = this.parseTemplateText();
          var d = this.opts.delimiter;
          var o = this.opts.openDelimiter;
          var c = this.opts.closeDelimiter;
          if (matches && matches.length) {
            matches.forEach(function(line, index) {
              var closing;
              if (line.indexOf(o + d) === 0 && line.indexOf(o + d + d) !== 0) {
                closing = matches[index + 2];
                if (!(closing == d + c || closing == "-" + d + c || closing == "_" + d + c)) {
                  throw new Error('Could not find matching close tag for "' + line + '".');
                }
              }
              self2.scanLine(line);
            });
          }
        }, parseTemplateText: function() {
          var str = this.templateText;
          var pat = this.regex;
          var result = pat.exec(str);
          var arr = [];
          var firstPos;
          while (result) {
            firstPos = result.index;
            if (firstPos !== 0) {
              arr.push(str.substring(0, firstPos));
              str = str.slice(firstPos);
            }
            arr.push(result[0]);
            str = str.slice(result[0].length);
            result = pat.exec(str);
          }
          if (str) {
            arr.push(str);
          }
          return arr;
        }, _addOutput: function(line) {
          if (this.truncate) {
            line = line.replace(/^(?:\r\n|\r|\n)/, "");
            this.truncate = false;
          }
          if (!line) {
            return line;
          }
          line = line.replace(/\\/g, "\\\\");
          line = line.replace(/\n/g, "\\n");
          line = line.replace(/\r/g, "\\r");
          line = line.replace(/"/g, '\\"');
          this.source += '    ; __append("' + line + '")\n';
        }, scanLine: function(line) {
          var self2 = this;
          var d = this.opts.delimiter;
          var o = this.opts.openDelimiter;
          var c = this.opts.closeDelimiter;
          var newLineCount = 0;
          newLineCount = line.split("\n").length - 1;
          switch (line) {
            case o + d:
            case o + d + "_":
              this.mode = Template.modes.EVAL;
              break;
            case o + d + "=":
              this.mode = Template.modes.ESCAPED;
              break;
            case o + d + "-":
              this.mode = Template.modes.RAW;
              break;
            case o + d + "#":
              this.mode = Template.modes.COMMENT;
              break;
            case o + d + d:
              this.mode = Template.modes.LITERAL;
              this.source += '    ; __append("' + line.replace(o + d + d, o + d) + '")\n';
              break;
            case d + d + c:
              this.mode = Template.modes.LITERAL;
              this.source += '    ; __append("' + line.replace(d + d + c, d + c) + '")\n';
              break;
            case d + c:
            case "-" + d + c:
            case "_" + d + c:
              if (this.mode == Template.modes.LITERAL) {
                this._addOutput(line);
              }
              this.mode = null;
              this.truncate = line.indexOf("-") === 0 || line.indexOf("_") === 0;
              break;
            default:
              if (this.mode) {
                switch (this.mode) {
                  case Template.modes.EVAL:
                  case Template.modes.ESCAPED:
                  case Template.modes.RAW:
                    if (line.lastIndexOf("//") > line.lastIndexOf("\n")) {
                      line += "\n";
                    }
                }
                switch (this.mode) {
                  case Template.modes.EVAL:
                    this.source += "    ; " + line + "\n";
                    break;
                  case Template.modes.ESCAPED:
                    this.source += "    ; __append(escapeFn(" + stripSemi(line) + "))\n";
                    break;
                  case Template.modes.RAW:
                    this.source += "    ; __append(" + stripSemi(line) + ")\n";
                    break;
                  case Template.modes.COMMENT:
                    break;
                  case Template.modes.LITERAL:
                    this._addOutput(line);
                    break;
                }
              } else {
                this._addOutput(line);
              }
          }
          if (self2.opts.compileDebug && newLineCount) {
            this.currentLine += newLineCount;
            this.source += "    ; __line = " + this.currentLine + "\n";
          }
        } };
        exports4.escapeXML = utils.escapeXML;
        exports4.__express = exports4.renderFile;
        exports4.VERSION = _VERSION_STRING;
        exports4.name = _NAME;
        if (typeof window != "undefined") {
          window.ejs = exports4;
        }
      }, { "../package.json": 6, "./utils": 2, fs: 3, path: 4 }], 2: [function(require2, module4, exports4) {
        "use strict";
        var regExpChars = /[|\\{}()[\]^$+*?.]/g;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var hasOwn = function(obj, key) {
          return hasOwnProperty.apply(obj, [key]);
        };
        exports4.escapeRegExpChars = function(string) {
          if (!string) {
            return "";
          }
          return String(string).replace(regExpChars, "\\$&");
        };
        var _ENCODE_HTML_RULES = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&#34;", "'": "&#39;" };
        var _MATCH_HTML = /[&<>'"]/g;
        function encode_char(c) {
          return _ENCODE_HTML_RULES[c] || c;
        }
        var escapeFuncStr = `var _ENCODE_HTML_RULES = {
      "&": "&amp;"
    , "<": "&lt;"
    , ">": "&gt;"
    , '"': "&#34;"
    , "'": "&#39;"
    }
  , _MATCH_HTML = /[&<>'"]/g;
function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
};
`;
        exports4.escapeXML = function(markup) {
          return markup == void 0 ? "" : String(markup).replace(_MATCH_HTML, encode_char);
        };
        function escapeXMLToString() {
          return Function.prototype.toString.call(this) + ";\n" + escapeFuncStr;
        }
        try {
          if (typeof Object.defineProperty === "function") {
            Object.defineProperty(exports4.escapeXML, "toString", { value: escapeXMLToString });
          } else {
            exports4.escapeXML.toString = escapeXMLToString;
          }
        } catch (err) {
          console.warn("Unable to set escapeXML.toString (is the Function prototype frozen?)");
        }
        exports4.shallowCopy = function(to, from) {
          from = from || {};
          if (to !== null && to !== void 0) {
            for (var p in from) {
              if (!hasOwn(from, p)) {
                continue;
              }
              if (p === "__proto__" || p === "constructor") {
                continue;
              }
              to[p] = from[p];
            }
          }
          return to;
        };
        exports4.shallowCopyFromList = function(to, from, list) {
          list = list || [];
          from = from || {};
          if (to !== null && to !== void 0) {
            for (var i = 0; i < list.length; i++) {
              var p = list[i];
              if (typeof from[p] != "undefined") {
                if (!hasOwn(from, p)) {
                  continue;
                }
                if (p === "__proto__" || p === "constructor") {
                  continue;
                }
                to[p] = from[p];
              }
            }
          }
          return to;
        };
        exports4.cache = { _data: {}, set: function(key, val) {
          this._data[key] = val;
        }, get: function(key) {
          return this._data[key];
        }, remove: function(key) {
          delete this._data[key];
        }, reset: function() {
          this._data = {};
        } };
        exports4.hyphenToCamel = function(str) {
          return str.replace(/-[a-z]/g, function(match) {
            return match[1].toUpperCase();
          });
        };
        exports4.createNullProtoObjWherePossible = function() {
          if (typeof Object.create == "function") {
            return function() {
              return /* @__PURE__ */ Object.create(null);
            };
          }
          if (!({ __proto__: null } instanceof Object)) {
            return function() {
              return { __proto__: null };
            };
          }
          return function() {
            return {};
          };
        }();
      }, {}], 3: [function(require2, module4, exports4) {
      }, {}], 4: [function(require2, module4, exports4) {
        (function(process) {
          function normalizeArray(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up--; up) {
                parts.unshift("..");
              }
            }
            return parts;
          }
          exports4.resolve = function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : process.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                continue;
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          };
          exports4.normalize = function(path) {
            var isAbsolute = exports4.isAbsolute(path), trailingSlash = substr(path, -1) === "/";
            path = normalizeArray(filter(path.split("/"), function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          };
          exports4.isAbsolute = function(path) {
            return path.charAt(0) === "/";
          };
          exports4.join = function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return exports4.normalize(filter(paths, function(p, index) {
              if (typeof p !== "string") {
                throw new TypeError("Arguments to path.join must be strings");
              }
              return p;
            }).join("/"));
          };
          exports4.relative = function(from, to) {
            from = exports4.resolve(from).substr(1);
            to = exports4.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "") break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "") break;
              }
              if (start > end) return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          };
          exports4.sep = "/";
          exports4.delimiter = ":";
          exports4.dirname = function(path) {
            if (typeof path !== "string") path = path + "";
            if (path.length === 0) return ".";
            var code = path.charCodeAt(0);
            var hasRoot = code === 47;
            var end = -1;
            var matchedSlash = true;
            for (var i = path.length - 1; i >= 1; --i) {
              code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  end = i;
                  break;
                }
              } else {
                matchedSlash = false;
              }
            }
            if (end === -1) return hasRoot ? "/" : ".";
            if (hasRoot && end === 1) {
              return "/";
            }
            return path.slice(0, end);
          };
          function basename(path) {
            if (typeof path !== "string") path = path + "";
            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1) return "";
            return path.slice(start, end);
          }
          exports4.basename = function(path, ext) {
            var f = basename(path);
            if (ext && f.substr(-1 * ext.length) === ext) {
              f = f.substr(0, f.length - ext.length);
            }
            return f;
          };
          exports4.extname = function(path) {
            if (typeof path !== "string") path = path + "";
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var preDotState = 0;
            for (var i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }
                continue;
              }
              if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
              if (code === 46) {
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
              } else if (startDot !== -1) {
                preDotState = -1;
              }
            }
            if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              return "";
            }
            return path.slice(startDot, end);
          };
          function filter(xs, f) {
            if (xs.filter) return xs.filter(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              if (f(xs[i], i, xs)) res.push(xs[i]);
            }
            return res;
          }
          var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
            return str.substr(start, len);
          } : function(str, start, len) {
            if (start < 0) start = str.length + start;
            return str.substr(start, len);
          };
        }).call(this, require2("_process"));
      }, { _process: 5 }], 5: [function(require2, module4, exports4) {
        var process = module4.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {
        }
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name) {
          return [];
        };
        process.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      }, {}], 6: [function(require2, module4, exports4) {
        module4.exports = { name: "ejs", description: "Embedded JavaScript templates", keywords: ["template", "engine", "ejs"], version: "3.1.9", author: "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)", license: "Apache-2.0", bin: { ejs: "./bin/cli.js" }, main: "./lib/ejs.js", jsdelivr: "ejs.min.js", unpkg: "ejs.min.js", repository: { type: "git", url: "git://github.com/mde/ejs.git" }, bugs: "https://github.com/mde/ejs/issues", homepage: "https://github.com/mde/ejs", dependencies: { jake: "^10.8.5" }, devDependencies: { browserify: "^16.5.1", eslint: "^6.8.0", "git-directory-deploy": "^1.5.1", jsdoc: "^4.0.2", "lru-cache": "^4.0.1", mocha: "^10.2.0", "uglify-js": "^3.3.16" }, engines: { node: ">=0.10.0" }, scripts: { test: "mocha -u tdd" } };
      }, {}] }, {}, [1])(1);
    });
  }
});

// ../jsbrains/smart-chat-model/adapters/anthropic.js
var require_anthropic = __commonJS({
  "../jsbrains/smart-chat-model/adapters/anthropic.js"(exports2) {
    var AnthropicAdapter = class {
      /**
       * Prepares the request body for the Anthropic API by converting ChatML format to a format compatible with Anthropic.
       * @param {Object} opts - The options object containing messages and other parameters in ChatML format.
       * @returns {Object} The request body formatted for the Anthropic API.
       */
      prepare_request_body(opts) {
        return chatml_to_anthropic(opts);
      }
      /**
       * Counts the tokens in the input by estimating them, as the Anthropic model does not provide a direct method.
       * @param {string|Object} input - The input text or object to count tokens in.
       * @returns {Promise<number>} The estimated number of tokens in the input.
       */
      async count_tokens(input) {
        return this.estimate_tokens(input);
      }
      /**
       * Estimates the number of tokens in the input based on a rough average token size.
       * @param {string|Object} input - The input text or object to estimate tokens in.
       * @returns {number} The estimated number of tokens.
       */
      estimate_tokens(input) {
        if (typeof input === "object") input = JSON.stringify(input);
        return Math.ceil(input.length / 6);
      }
      /**
       * Extracts the first tool call from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object|null} The first tool call found, or null if none exist.
       */
      get_tool_call(json) {
        return json.content.find((msg) => msg.type === "tool_use");
      }
      /**
       * Retrieves the input content of a tool call.
       * @param {Object} tool_call - The tool call object from which to extract the input.
       * @returns {Object} The input of the tool call.
       */
      get_tool_call_content(tool_call) {
        return tool_call.input;
      }
      /**
       * Retrieves the name of the tool from a tool call object.
       * @param {Object} tool_call - The tool call object from which to extract the name.
       * @returns {string} The name of the tool.
       */
      get_tool_name(tool_call) {
        return tool_call.name;
      }
      /**
       * Extracts the first message from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object|null} The first message found, or null if none exist.
       */
      get_message(json) {
        return json.content?.[0];
      }
      /**
       * Retrieves the content of the first message from the JSON response.
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string|null} The content of the first message, or null if no message is found.
       */
      get_message_content(json) {
        return this.get_message(json)?.[this.get_message(json)?.type];
      }
    };
    exports2.AnthropicAdapter = AnthropicAdapter;
    function chatml_to_anthropic(opts) {
      let tool_counter = 0;
      const messages = opts.messages.filter((msg) => msg.role !== "system").map((m) => {
        if (m.role === "tool") {
          return { role: "user", content: [
            {
              type: "tool_result",
              tool_use_id: `tool-${tool_counter}`,
              content: m.content
            }
          ] };
        }
        if (m.role === "assistant" && m.tool_calls) {
          tool_counter++;
          const out2 = {
            role: m.role,
            content: m.tool_calls.map((c) => ({
              type: "tool_use",
              id: `tool-${tool_counter}`,
              name: c.function.name,
              input: typeof c.function.arguments === "string" ? JSON.parse(c.function.arguments) : c.function.arguments
            }))
          };
          if (m.content) {
            if (typeof m.content === "string") out2.content.push({ type: "text", text: m.content });
            else m.content.forEach((c) => out2.content.push(c));
          }
          return out2;
        }
        if (typeof m.content === "string") return { role: m.role, content: m.content };
        if (Array.isArray(m.content)) {
          const content = m.content.map((c) => {
            if (c.type === "text") return { type: "text", text: c.text };
            if (c.type === "image_url") {
              const image_url = c.image_url.url;
              let media_type = image_url.split(":")[1].split(";")[0];
              if (media_type === "image/jpg") media_type = "image/jpeg";
              return { type: "image", source: { type: "base64", media_type, data: image_url.split(",")[1] } };
            }
          });
          return { role: m.role, content };
        }
        return m;
      });
      const { model, max_tokens, temperature, tools, tool_choice } = opts;
      const last_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && msg.content.includes("---BEGIN"));
      if (last_system_idx > -1) {
        const system_prompt = "<context>\n" + opts.messages[last_system_idx].content + "\n</context>\n";
        messages[messages.length - 1].content = system_prompt + messages[messages.length - 1].content;
      }
      console.log(messages);
      const out = {
        messages,
        model,
        max_tokens,
        temperature
      };
      if (tools) {
        out.tools = tools.map((tool) => ({
          name: tool.function.name,
          description: tool.function.description,
          input_schema: tool.function.parameters
        }));
        if (tool_choice?.type === "function") {
          const tool_prompt = `Use the "${tool_choice.function.name}" tool!`;
          const last_user_idx = out.messages.findLastIndex((msg) => msg.role === "user");
          out.messages[last_user_idx].content += "\n" + tool_prompt;
          out.system = `Required: use the "${tool_choice.function.name}" tool!`;
        }
      }
      const last_non_context_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && !msg.content.includes("---BEGIN"));
      if (last_non_context_system_idx > -1) out.system = opts.messages[last_non_context_system_idx].content;
      return out;
    }
    exports2.chatml_to_anthropic = chatml_to_anthropic;
  }
});

// ../jsbrains/smart-chat-model/adapters/cohere.js
var require_cohere = __commonJS({
  "../jsbrains/smart-chat-model/adapters/cohere.js"(exports2) {
    var CohereAdapter = class {
      /**
       * Converts a ChatML object to a format suitable for a request to the Cohere API.
       * @param {Object} chatml - The ChatML object containing the chat history and other parameters.
       * @returns {Object} The request body formatted for the Cohere API.
       */
      prepare_request_body(chatml) {
        return chatml_to_cohere(chatml);
      }
      /**
       * Extracts the message content from a JSON response from the Cohere API.
       * @param {Object} json - The JSON response object from which to extract the text content.
       * @returns {string} The extracted text content from the response.
       */
      get_message_content(json) {
        return json.text;
      }
      /**
       * Processes streaming data received from the Cohere API and extracts text chunks.
       * This method handles the accumulation of text data over multiple events and manages the state of the stream.
       * @param {Object} event - The event object containing streaming data.
       * @returns {string} The accumulated text chunk extracted from the stream.
       */
      get_text_chunk_from_stream(event) {
        if (!this.last_line_index) this.last_line_index = 0;
        clearTimeout(this.last_line_timeout);
        this.last_line_timeout = setTimeout(() => {
          this.last_line_index = 0;
        }, 1e4);
        const data = event.source.xhr.responseText;
        const lines = data.split("\n").slice(this.last_line_index);
        console.log(lines);
        this.last_line_index += lines.length;
        const text_chunk = lines.filter((line) => line.trim() !== "").map((line) => {
          console.log(line);
          const json = JSON.parse(line);
          if (json.event_type === "stream-end") {
            console.log("stream-end");
            this.end_of_stream = true;
            setTimeout(() => {
              this.end_of_stream = false;
            }, 3e3);
            return "";
          }
          return json.text;
        }).join("");
        console.log(text_chunk);
        return text_chunk;
      }
      /**
       * Determines if the end of the stream has been reached based on the event data.
       * @param {Object} event - The event object that may indicate the end of the stream.
       * @returns {boolean} True if the end of the stream is indicated, false otherwise.
       */
      is_end_of_stream(event) {
        return this.end_of_stream;
      }
    };
    exports2.CohereAdapter = CohereAdapter;
    function chatml_to_cohere(chatml) {
      const cohere = {
        model: chatml.model,
        // skip last user message
        chat_history: chatml.messages.slice(0, -1).map((message) => ({
          role: message.role,
          message: parse_message_content_to_string(message)
        })),
        message: parse_message_content_to_string(chatml.messages[chatml.messages.length - 1]),
        temperature: chatml.temperature
        // stream: chatml.stream // currently not supported
      };
      return cohere;
    }
    exports2.chatml_to_cohere = chatml_to_cohere;
    function parse_message_content_to_string(message) {
      return Array.isArray(message.content) ? message.content.filter((c) => c.type === "text").map((c) => c.text).join("\n") : message.content;
    }
  }
});

// ../jsbrains/smart-chat-model/adapters/gemini.js
var require_gemini = __commonJS({
  "../jsbrains/smart-chat-model/adapters/gemini.js"(exports2) {
    var GeminiAdapter = class {
      /**
       * Constructs a GeminiAdapter instance with a specified model configuration.
       * @param {Object} model - The model configuration object.
       */
      constructor(model) {
        this.model = model;
      }
      /**
       * Prepares the request body for the Gemini API by converting ChatML format to a format compatible with Gemini.
       * @param {Object} body - The options object containing messages and other parameters in ChatML format.
       * @returns {Object} The request body formatted for the Gemini API.
       */
      prepare_request_body(body) {
        return chatml_to_gemini(body);
      }
      /**
       * Extracts the first tool call from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object|null} The first tool call found, or null if none exist.
       */
      get_tool_call(json) {
        return json.candidates?.[0]?.content?.parts?.[0]?.functionCall;
      }
      /**
       * Retrieves the name of the tool from a tool call object.
       * @param {Object} tool_call - The tool call object from which to extract the name.
       * @returns {string|null} The name of the tool, or null if not available.
       */
      get_tool_name(tool_call) {
        return tool_call?.name;
      }
      /**
       * Retrieves the input content of a tool call.
       * @param {Object} tool_call - The tool call object from which to extract the input.
       * @returns {Object|null} The input of the tool call, or null if not available.
       */
      get_tool_call_content(tool_call) {
        return tool_call?.args;
      }
      /**
       * Extracts the first message from the JSON response content.
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object|null} The first message found, or null if none exist.
       */
      get_message(json) {
        return json.candidates?.[0];
      }
      /**
       * Retrieves the content of the first message from the JSON response.
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string|null} The content of the first message, or null if no message is found.
       */
      get_message_content(json) {
        return this.get_message(json)?.content?.parts.map((part) => part.text).join("");
      }
      /**
       * Handles escaped newlines in a streaming text chunk.
       * @param {Object} event - The streaming event containing the data.
       * @returns {string} The text chunk with escaped newlines replaced.
       */
      get_text_chunk_from_stream(event) {
        return event.data.replace(/\\n/g, "\n");
      }
      /**
       * Determines if the streaming response has ended based on the readyState of the XMLHttpRequest.
       * @param {Object} event - The streaming event.
       * @returns {boolean} True if the stream has ended, false otherwise.
       */
      is_end_of_stream(event) {
        return event.source.xhr.readyState === 4;
      }
      /**
       * Counts the tokens in the input by making an API request to the Gemini token counting endpoint.
       * @param {string|Object} input - The input text or object to count tokens in.
       * @returns {Promise<number>} The total number of tokens in the input.
       */
      async count_tokens(input) {
        const req = {
          url: `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:countTokens?key=${this.model.api_key}`,
          method: "POST",
          headers: { "Content-Type": "application/json" }
        };
        let body;
        if (typeof input === "string") body = chatml_to_gemini({ messages: [{ role: "user", content: input }] });
        else if (Array.isArray(input)) body = chatml_to_gemini({ messages: input });
        else if (typeof input === "object") body = chatml_to_gemini(input);
        else return console.error("Invalid input for count_tokens", input);
        delete body.generationConfig;
        delete body.safetySettings;
        req.body = JSON.stringify(body);
        const resp = await this.model.request_adapter(req);
        return resp?.json?.totalTokens;
      }
      /**
       * Getter for the standard API endpoint with the API key appended.
       * @returns {string} The formatted endpoint URL for non-streaming requests.
       */
      get endpoint() {
        return this.model.config.endpoint.replace("MODEL_NAME", this.model.model_name) + "?key=" + this.model.api_key;
      }
      /**
       * Getter for the streaming API endpoint with the API key appended.
       * @returns {string} The formatted endpoint URL for streaming requests.
       */
      get endpoint_streaming() {
        return this.model.config.endpoint_streaming.replace("MODEL_NAME", this.model.model_name) + "?key=" + this.model.api_key;
      }
    };
    exports2.GeminiAdapter = GeminiAdapter;
    function chatml_to_gemini(opts) {
      const messages = opts.messages.filter((msg) => msg.role !== "system");
      const last_system_idx = opts.messages.findLastIndex((msg) => msg.role === "system" && msg.content.includes("---BEGIN"));
      if (last_system_idx > -1) {
        const system_prompt = "---BEGIN IMPORTANT CONTEXT---\n" + opts.messages[last_system_idx].content + "\n---END IMPORTANT CONTEXT---\n\n";
        messages[messages.length - 1].content = system_prompt + messages[messages.length - 1].content;
      }
      const body = {
        contents: messages.filter((msg) => msg.role !== "system").map((msg) => {
          const content = {};
          content.role = msg.role === "assistant" ? "model" : msg.role;
          content.parts = !Array.isArray(msg.content) ? [{ text: msg.content }] : msg.content.map((c) => {
            if (c.type === "text") {
              return { text: c.text };
            }
            if (c.type === "image_url") {
              const image_url = c.image_url.url;
              let mime_type = image_url.split(":")[1].split(";")[0];
              if (mime_type === "image/jpg") mime_type = "image/jpeg";
              return { inline_data: { mime_type, data: image_url.split(",")[1] } };
            }
          });
          return content;
          ({
            role: msg.role === "assistant" ? "model" : msg.role,
            parts: Array.isArray(msg.content) ? [{ text: msg.content.filter((c) => c.type === "text").map((c) => c.text).join("\n") }] : [{ text: msg.content }]
          });
        }),
        generationConfig: {
          temperature: opts.temperature || 0.9,
          topK: opts.topK || 1,
          topP: opts.topP || 1,
          maxOutputTokens: opts.max_tokens || 2048,
          stopSequences: opts.stopSequences || [],
          candidate_count: opts.n || 1
        },
        safetySettings: [
          {
            category: "HARM_CATEGORY_HARASSMENT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_HATE_SPEECH",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_DANGEROUS_CONTENT",
            threshold: "BLOCK_NONE"
          }
        ]
      };
      const system_instructions = opts.messages.filter((msg) => msg.role === "system" && !msg.content.includes("---BEGIN"));
      if (system_instructions.length > 0) body.systemInstruction = { parts: system_instructions.map((msg) => ({ text: msg.content })) };
      if (opts.tools) {
        body.tools = [{
          function_declarations: opts.tools.map((tool) => ({
            name: tool.function.name,
            description: tool.function.description,
            parameters: tool.function.parameters
          }))
        }];
        if (opts.tool_choice) {
          if (opts.tool_choice !== "auto") {
            if (opts.model.includes("1.5") || opts.model.includes("flash")) {
              body.tool_config = {
                function_calling_config: {
                  mode: "ANY",
                  allowed_function_names: opts.tools.map((tool) => tool.function.name)
                }
              };
              body.systemInstruction = {
                role: "user",
                parts: [
                  {
                    text: `IMPORTANT: You must use the "${body.tools[0].function_declarations[0].name}" function tool!`
                  }
                ]
              };
            }
            const tool_prompt = `IMPORTANT: You must use the "${body.tools[0].function_declarations[0].name}" function tool!`;
            const last_user_idx = body.contents.findLastIndex((msg) => msg.role === "user");
            body.contents[last_user_idx].parts[0].text += "\n\n" + tool_prompt;
          }
        }
      }
      return body;
    }
    exports2.chatml_to_gemini = chatml_to_gemini;
  }
});

// ../jsbrains/smart-chat-model/adapters/open_router.js
var require_open_router = __commonJS({
  "../jsbrains/smart-chat-model/adapters/open_router.js"(exports2) {
    var OpenRouterAdapter = class {
      constructor(model) {
        this.model = model;
      }
      get_tool_call(json) {
        if (json.choices[0].message.tool_calls) {
          return json.choices[0].message.tool_calls[0].function;
        }
        if (json.choices[0].message.content.includes("function")) {
          const content = JSON.parse(json.choices[0].message.content);
          if (!content.function) return null;
          return content;
        }
        return null;
      }
      get_tool_name(tool_call) {
        if (tool_call.function) return tool_call.function;
        if (tool_call.name) return tool_call.name;
        return null;
      }
      get_tool_call_content(tool_call) {
        if (tool_call.parameters) return tool_call.parameters;
        if (tool_call.arguments) {
          const args = JSON.parse(tool_call.arguments);
          Object.entries(args).forEach(([key, value]) => {
            args[key] = value.replace(/\\n/g, "\n").replace(/\\t/g, "	").replace(/\\r/g, "\r").replace(/\\'/g, "'").replace(/\\"/g, '"');
          });
          return args;
        }
        return null;
      }
    };
    exports2.OpenRouterAdapter = OpenRouterAdapter;
  }
});

// ../jsbrains/smart-chat-model/adapters.js
var require_adapters = __commonJS({
  "../jsbrains/smart-chat-model/adapters.js"(exports2) {
    var { AnthropicAdapter } = require_anthropic();
    var { CohereAdapter } = require_cohere();
    var { GeminiAdapter } = require_gemini();
    var { OpenRouterAdapter } = require_open_router();
    exports2.Anthropic = AnthropicAdapter;
    exports2.Cohere = CohereAdapter;
    exports2.Gemini = GeminiAdapter;
    exports2.OpenRouter = OpenRouterAdapter;
  }
});

// ../jsbrains/smart-chat-model/platforms.json
var require_platforms = __commonJS({
  "../jsbrains/smart-chat-model/platforms.json"(exports2, module2) {
    module2.exports = {
      openai: {
        description: "OpenAI",
        type: "API",
        endpoint: "https://api.openai.com/v1/chat/completions",
        streaming: true,
        actions: true,
        fetch_models: true,
        default_model: "gpt-3.5-turbo",
        signup_url: "https://platform.openai.com/api-keys"
      },
      google_gemini: {
        description: "Google Gemini",
        type: "API",
        api_key_header: "none",
        endpoint: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:generateContent",
        endpoint_streaming: "https://generativelanguage.googleapis.com/v1beta/models/MODEL_NAME:streamGenerateContent",
        streaming: true,
        actions: true,
        adapter: "Gemini",
        fetch_models: true,
        default_model: "gemini-1.5-pro",
        signup_url: "https://ai.google.dev/"
      },
      open_router: {
        description: "Open Router",
        type: "API",
        endpoint: "https://openrouter.ai/api/v1/chat/completions",
        streaming: true,
        adapter: "OpenRouter",
        fetch_models: true,
        default_model: "mistralai/mistral-7b-instruct:free",
        signup_url: "https://accounts.openrouter.ai/sign-up?redirect_url=https%3A%2F%2Fopenrouter.ai%2Fkeys"
      },
      cohere: {
        description: "Cohere Command-R",
        type: "API",
        endpoint: "https://api.cohere.ai/v1/chat",
        streaming: false,
        adapter: "Cohere",
        fetch_models: true,
        default_model: "command-r",
        signup_url: "https://dashboard.cohere.com/welcome/register?redirect_uri=%2Fapi-keys"
      },
      anthropic: {
        description: "Anthropic Claude",
        type: "API",
        endpoint: "https://api.anthropic.com/v1/messages",
        streaming: false,
        api_key_header: "x-api-key",
        headers: {
          "anthropic-version": "2023-06-01",
          "anthropic-beta": "tools-2024-04-04"
        },
        adapter: "Anthropic",
        actions: true,
        fetch_models: true,
        default_model: "claude-3-sonnet-20240229",
        signup_url: "https://console.anthropic.com/login?returnTo=%2Fsettings%2Fkeys"
      },
      custom_local: {
        description: "Custom Local (OpenAI format)",
        type: "API"
      },
      custom_api: {
        description: "Custom API (OpenAI format)",
        type: "API"
      }
    };
  }
});

// ../jsbrains/smart-chat-model/utils/is_valid_tool_call.js
var require_is_valid_tool_call = __commonJS({
  "../jsbrains/smart-chat-model/utils/is_valid_tool_call.js"(exports2) {
    function is_valid_tool_call(tool, tool_call_content) {
      const props = tool.function.parameters.properties;
      if (typeof props !== "undefined" && Object.keys(tool_call_content).length === 0) {
        console.warn(`Invalid tool call: object is empty`);
        return false;
      }
      Object.entries(tool_call_content).forEach(([key, value]) => {
        if (!props[key]) {
          console.warn(`Invalid tool call: missing key ${key} in tool spec`, props);
          return false;
        }
        if (Array.isArray(value) && props[key].type === "array") {
          const itemType = typeof value[0];
          if (!value.every((item) => typeof item === itemType)) {
            console.warn(`Invalid tool call: array items are not of the same type`);
            return false;
          }
          if (props[key].items.type !== itemType) {
            console.warn(`Invalid tool call: array items are not of the same type as the spec`);
            return false;
          }
        } else if (props[key].type !== typeof value) {
          if (props[key].type === "number" && typeof value === "string") {
            if (isNaN(Number(value))) {
              console.warn(`Invalid tool call: value ${value} is not a valid number`);
              return false;
            }
            tool_call_content[key] = Number(value);
          } else {
            console.warn(`Invalid tool call: value ${value} is not of type ${props[key].type}`);
            return false;
          }
        }
        if (props[key].enum && !props[key].enum.includes(value)) {
          console.warn(`Invalid tool call: value ${value} is not in enum ${props[key].enum}`);
          return false;
        }
      });
      tool.function.parameters.required?.forEach((key) => {
        if (typeof tool_call_content[key] === "undefined") {
          console.warn(`Invalid tool call: missing required key ${key}`);
          return false;
        }
        if (tool_call_content[key] === "") {
          console.warn(`Empty value for required key ${key}`);
          return false;
        }
      });
      return true;
    }
    exports2.is_valid_tool_call = is_valid_tool_call;
  }
});

// ../jsbrains/smart-chat-model/streamer.js
var require_streamer = __commonJS({
  "../jsbrains/smart-chat-model/streamer.js"(exports2) {
    var SmartStreamer = class {
      constructor(url, options = {}) {
        const {
          method = "GET",
          headers = {},
          body = null,
          withCredentials = false
        } = options;
        this.url = url;
        this.method = method;
        this.headers = headers;
        this.body = body;
        this.withCredentials = withCredentials;
        this.listeners = {};
        this.readyState = this.CONNECTING;
        this.progress = 0;
        this.chunk = "";
        this.last_event_id = "";
        this.xhr = null;
        this.FIELD_SEPARATOR = ":";
        this.INITIALIZING = -1;
        this.CONNECTING = 0;
        this.OPEN = 1;
        this.CLOSED = 2;
      }
      /**
       * Adds an event listener for the specified event type.
       *
       * @param {string} type - The type of the event.
       * @param {Function} listener - The listener function to be called when the event is triggered.
       */
      addEventListener(type, listener) {
        if (!this.listeners[type]) this.listeners[type] = [];
        if (!this.listeners[type].includes(listener)) this.listeners[type].push(listener);
      }
      /**
       * Removes an event listener from the SmartStreamer instance.
       *
       * @param {string} type - The type of event to remove the listener from.
       * @param {Function} listener - The listener function to remove.
       */
      removeEventListener(type, listener) {
        if (!this.listeners[type]) return;
        this.listeners[type] = this.listeners[type].filter((callback) => callback !== listener);
        if (this.listeners[type].length === 0) delete this.listeners[type];
      }
      /**
       * Dispatches an event to the appropriate event handlers.
       *
       * @param {Event} event - The event to be dispatched.
       * @returns {boolean} - Returns true if the event was successfully dispatched, false otherwise.
       */
      dispatchEvent(event) {
        if (!event) return true;
        event.source = this;
        const onHandler = "on" + event.type;
        if (Object.prototype.hasOwnProperty.call(this, onHandler)) {
          this[onHandler].call(this, event);
          if (event.defaultPrevented) return false;
        }
        if (this.listeners[event.type]) {
          this.listeners[event.type].forEach((callback) => {
            callback(event);
            return !event.defaultPrevented;
          });
        }
        return true;
      }
      /**
       * Initiates the streaming process.
       */
      stream() {
        this.#setReadyState(this.CONNECTING);
        this.xhr = new XMLHttpRequest();
        this.xhr.addEventListener("progress", this.#onStreamProgress.bind(this));
        this.xhr.addEventListener("load", this.#onStreamLoaded.bind(this));
        this.xhr.addEventListener("readystatechange", this.#checkStreamClosed.bind(this));
        this.xhr.addEventListener("error", this.#onStreamFailure.bind(this));
        this.xhr.addEventListener("abort", this.#onStreamAbort.bind(this));
        this.xhr.open(this.method, this.url);
        for (const header in this.headers) {
          this.xhr.setRequestHeader(header, this.headers[header]);
        }
        if (this.last_event_id) this.xhr.setRequestHeader("Last-Event-ID", this.last_event_id);
        this.xhr.withCredentials = this.withCredentials;
        this.xhr.send(this.body);
      }
      /**
       * Ends the streamer connection.
       * Aborts the current XHR request and sets the ready state to CLOSED.
       */
      end() {
        if (this.readyState === this.CLOSED) return;
        this.xhr.abort();
        this.xhr = null;
        this.#setReadyState(this.CLOSED);
      }
      // private methods
      #setReadyState(state) {
        const event = new CustomEvent("readyStateChange");
        event.readyState = state;
        this.readyState = state;
        this.dispatchEvent(event);
      }
      #onStreamFailure(e) {
        const event = new CustomEvent("error");
        event.data = e.currentTarget.response;
        this.dispatchEvent(event);
        this.end();
      }
      #onStreamAbort(e) {
        const event = new CustomEvent("abort");
        this.end();
      }
      #onStreamProgress(e) {
        if (!this.xhr) return;
        if (this.xhr.status !== 200) {
          this.#onStreamFailure(e);
          return;
        }
        if (this.readyState === this.CONNECTING) {
          this.dispatchEvent(new CustomEvent("open"));
          this.#setReadyState(this.OPEN);
        }
        const data = this.xhr.responseText.substring(this.progress);
        this.progress += data.length;
        data.split(/(\r\n|\r|\n)/g).forEach((part) => {
          if (part.trim().length === 0) {
            this.dispatchEvent(this.#parseEventChunk(this.chunk.trim()));
            this.chunk = "";
          } else {
            this.chunk += part;
          }
        });
      }
      #onStreamLoaded(e) {
        this.#onStreamProgress(e);
        this.dispatchEvent(this.#parseEventChunk(this.chunk));
        this.chunk = "";
      }
      #parseEventChunk(chunk) {
        if (!chunk || chunk.length === 0) return null;
        const e = { id: null, retry: null, data: "", event: "message", text: "" };
        chunk.split(/(\r\n|\r|\n)/).forEach((line) => {
          line = line.trim();
          const index = line.indexOf(this.FIELD_SEPARATOR);
          if (index <= 0) return;
          const field = line.substring(0, index).replace(/^"|"$/g, "");
          if (!["id", "retry", "data", "event", "text"].includes(field)) return;
          const value = line.substring(index + 1).trim().replace(/^"|"$/g, "");
          e.data += value;
        });
        if (e.id) this.last_event_id = e.id;
        const event = new CustomEvent(e.event || "message");
        event.id = e.id;
        event.data = e.data || "";
        event.last_event_id = this.last_event_id;
        return event;
      }
      #checkStreamClosed() {
        if (!this.xhr) return;
        if (this.xhr.readyState === XMLHttpRequest.DONE) this.#setReadyState(this.CLOSED);
      }
    };
    exports2.SmartStreamer = SmartStreamer;
  }
});

// ../jsbrains/smart-chat-model/models/open_router.js
var require_open_router2 = __commonJS({
  "../jsbrains/smart-chat-model/models/open_router.js"(exports2) {
    async function fetch_open_router_models(api_key, request_adapter = null) {
      try {
        let data;
        if (!request_adapter) {
          const response = await fetch("https://openrouter.ai/api/v1/models");
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          data = await response.json();
          console.log("Model data retrieved:", data);
        } else {
          const resp = await request_adapter({
            url: "https://openrouter.ai/api/v1/models"
          });
          data = await resp.json;
        }
        return data.data.map((model) => ({
          model_name: model.id,
          key: model.id,
          max_input_tokens: model.context_length,
          description: model.name,
          actions: model.description.includes("tool use") || model.description.includes("function call"),
          multimodal: model.architecture.modality === "multimodal",
          raw: model
        }));
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_open_router_models = fetch_open_router_models;
  }
});

// ../jsbrains/smart-chat-model/models/openai.js
var require_openai = __commonJS({
  "../jsbrains/smart-chat-model/models/openai.js"(exports2) {
    var model_context = {
      "gpt-3.5-turbo-0125": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-0301": {
        "context": 4097,
        "max_out": 4097
      },
      "gpt-3.5-turbo-0613": {
        "context": 4097,
        "max_out": 4097
      },
      "gpt-3.5-turbo-1106": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-3.5-turbo-16k": {
        "context": 16385,
        "max_out": 16385
      },
      "gpt-3.5-turbo-16k-0613": {
        "context": 16385,
        "max_out": 16385
      },
      "gpt-4-0125-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-0314": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-0613": {
        "context": 8192,
        "max_out": 8192
      },
      "gpt-4-1106-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-1106-vision-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-32k-0314": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-32k-0613": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4-turbo-2024-04-09": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-turbo-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-vision-preview": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-3.5-turbo": {
        "context": 16385,
        "max_out": 4096
      },
      "gpt-4-turbo": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4-32k": {
        "context": 32768,
        "max_out": 32768
      },
      "gpt-4o": {
        "context": 128e3,
        "max_out": 4096
      },
      "gpt-4": {
        "context": 8192,
        "max_out": 8192
      }
    };
    async function fetch_openai_models(api_key, request_adapter = null) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        let data;
        if (!request_adapter) {
          console.log("Using fetch");
          const response = await fetch("https://api.openai.com/v1/models", {
            headers: {
              "Authorization": `Bearer ${api_key}`
            }
          });
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          data = await response.json();
          console.log("Model data retrieved:", data);
        } else {
          console.log("Using request adapter");
          const resp = await request_adapter({
            url: "https://api.openai.com/v1/models",
            headers: {
              "Authorization": `Bearer ${api_key}`
            }
          });
          data = await resp.json;
        }
        return data.data.filter((model) => model.id.startsWith("gpt-") && !model.id.includes("-instruct")).map((model) => {
          const out = {
            model_name: model.id,
            key: model.id,
            multimodal: model.id.includes("vision") || model.id.includes("gpt-4-turbo")
          };
          const m = Object.entries(model_context).find((m2) => m2[0] === model.id || model.id.startsWith(m2[0] + "-"));
          if (m) {
            out.max_input_tokens = m[1].context;
            out.description = `context: ${m[1].context}, output: ${m[1].max_out}`;
          }
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_openai_models = fetch_openai_models;
  }
});

// ../jsbrains/smart-chat-model/models/google_gemini.js
var require_google_gemini = __commonJS({
  "../jsbrains/smart-chat-model/models/google_gemini.js"(exports2) {
    async function fetch_google_gemini_models(api_key, request_adapter = null) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        let data;
        if (!request_adapter) {
          const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models?key=" + api_key);
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          data = await response.json();
          console.log("Model data retrieved:", data);
        } else {
          const resp = await request_adapter({
            url: "https://generativelanguage.googleapis.com/v1beta/models?key=" + api_key
          });
          console.log(JSON.stringify(resp));
          data = await resp.json;
        }
        return data.models.filter((model) => model.name.startsWith("models/gemini")).map((model) => {
          const out = {
            model_name: model.name.split("/").pop(),
            key: model.name.split("/").pop(),
            max_input_tokens: model.inputTokenLimit,
            max_output_tokens: model.maxOutputTokens,
            description: model.description,
            multimodal: model.name.includes("vision") || model.description.includes("multimodal"),
            raw: model
          };
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_google_gemini_models = fetch_google_gemini_models;
  }
});

// ../jsbrains/smart-chat-model/models/cohere.js
var require_cohere2 = __commonJS({
  "../jsbrains/smart-chat-model/models/cohere.js"(exports2) {
    async function fetch_cohere_models(api_key, request_adapter = null) {
      if (!api_key) {
        console.error("No API key provided");
        return [];
      }
      try {
        let data;
        if (!request_adapter) {
          const response = await fetch("https://api.cohere.ai/v1/models", {
            headers: {
              "Authorization": `Bearer ${api_key}`
            }
          });
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          data = await response.json();
          console.log("Model data retrieved:", data);
        } else {
          const resp = await request_adapter({
            url: "https://api.cohere.ai/v1/models",
            headers: {
              "Authorization": `Bearer ${api_key}`
            }
          });
          data = await resp.json;
        }
        console.log("Model data retrieved:", data);
        return data.models.filter((model) => model.name.startsWith("command-")).map((model) => {
          const out = {
            model_name: model.name,
            key: model.name,
            max_input_tokens: model.context_length,
            tokenizer_url: model.tokenizer_url,
            finetuned: model.finetuned,
            description: `Max input tokens: ${model.context_length}, Finetuned: ${model.finetuned}`
          };
          return out;
        });
      } catch (error) {
        console.error("Failed to fetch model data:", error);
        return [];
      }
    }
    exports2.fetch_cohere_models = fetch_cohere_models;
  }
});

// ../jsbrains/smart-chat-model/models/anthropic.js
var require_anthropic2 = __commonJS({
  "../jsbrains/smart-chat-model/models/anthropic.js"(exports2) {
    async function fetch_anthropic_models() {
      return [
        {
          "key": "claude-3-opus-20240229",
          "model_name": "claude-3-opus-20240229",
          "description": "Anthropic's Claude Opus",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        },
        {
          key: "claude-3-5-sonnet-20240620",
          "model_name": "claude-3.5-sonnet-20240620",
          "description": "Anthropic's Claude Sonnet",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        },
        {
          key: "claude-3-haiku-20240307",
          "model_name": "claude-3-haiku-20240307",
          "description": "Anthropic's Claude Haiku",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        },
        {
          key: "claude-3-sonnet-20240229",
          "model_name": "claude-3-sonnet-20240229",
          "description": "Anthropic's Claude Sonnet",
          "max_input_tokens": 2e5,
          "max_output_tokens": 4e3,
          "multimodal": true
        }
      ];
    }
    exports2.fetch_anthropic_models = fetch_anthropic_models;
  }
});

// ../jsbrains/smart-chat-model/models/fetch.js
var require_fetch = __commonJS({
  "../jsbrains/smart-chat-model/models/fetch.js"(exports2) {
    var { fetch_open_router_models } = require_open_router2();
    var { fetch_openai_models } = require_openai();
    var { fetch_google_gemini_models } = require_google_gemini();
    var { fetch_cohere_models } = require_cohere2();
    var { fetch_anthropic_models } = require_anthropic2();
    exports2.open_router = fetch_open_router_models;
    exports2.openai = fetch_openai_models;
    exports2.google_gemini = fetch_google_gemini_models;
    exports2.cohere = fetch_cohere_models;
    exports2.anthropic = fetch_anthropic_models;
  }
});

// ../jsbrains/smart-chat-model/smart_chat_model.js
var require_smart_chat_model = __commonJS({
  "../jsbrains/smart-chat-model/smart_chat_model.js"(exports2) {
    var adapters = require_adapters();
    var platforms = require_platforms();
    var { is_valid_tool_call } = require_is_valid_tool_call();
    var { SmartStreamer } = require_streamer();
    var fetch_models = require_fetch();
    var SmartChatModel3 = class {
      /**
       * Constructs an instance of SmartChatModel with specified environment, model key, and options.
       * @param {Object} main - The main environment context, typically containing configurations and state.
       * @param {string} platform_key - Key to select the specific model configuration from models.json.
       * @param {Object} model_config - Optional parameters to override model configurations.
       */
      constructor(main, platform_key, model_config = {}) {
        this.env = main;
        this.main = this.env;
        this.config = {
          ...platforms[platform_key] || {},
          ...model_config
          // override default platform config
        };
        console.log(JSON.stringify(this.config));
        this.platform_key = platform_key;
        this.active_stream = null;
        this._request_adapter = null;
        this.platforms = platforms;
        if (this.config.adapter) this.adapter = new adapters[this.config.adapter](this);
        if (this.adapter) console.log("has chat model adapter");
      }
      static get models() {
        return platforms;
      }
      // DEPRECATED (confusing name)
      // 
      static get platforms() {
        return Object.keys(platforms).map((key) => ({
          key,
          ...platforms[key]
        }));
      }
      get platform() {
        return platforms[this.platform_key];
      }
      get default_opts() {
        return {
          temperature: 0.3,
          top_p: 1,
          presence_penalty: 0,
          frequency_penalty: 0,
          n: 1,
          model: this.model_name,
          max_tokens: this.max_output_tokens
        };
      }
      async request_middlewares(opts) {
        return opts;
      }
      /**
       * Completes the chat interaction by processing the provided options, making an API request, and handling the response.
       * This method supports both streaming and non-streaming responses, and can handle tool calls if specified in the response.
       *
       * @param {Object} opts - The options for the chat completion which may include settings like temperature, max tokens, etc.
       * @param {boolean} render - Flag to determine if the response should be rendered in the UI.
       * @returns {Promise<string|void>} - Returns the chat response content or handles tool outputs recursively. In case of errors, it may return an error message.
       */
      async complete(opts = {}, render = true) {
        const prepared_opts = await this.prepare_options(opts);
        const request2 = this.create_request(prepared_opts);
        try {
          if (prepared_opts.stream) {
            return await this.handle_streaming_request(request2, render);
          }
          return await this.handle_non_streaming_request(request2, prepared_opts, render);
        } catch (err) {
          return this.handle_error(err, render);
        }
      }
      async prepare_options(opts) {
        if (!this.base_model_config) {
          this.base_model_config = await this.get_base_model_config();
          this.config = {
            ...this.base_model_config,
            ...this.config
          };
        }
        const prepared_opts = {
          ...this.default_opts,
          messages: (await this.current?.get_chat_ml())?.messages || [],
          ...opts
        };
        if (prepared_opts.stream !== false && this.config.streaming && !this.current?.tool_choice) {
          prepared_opts.stream = true;
        } else {
          prepared_opts.stream = false;
        }
        return this.request_middlewares(JSON.parse(JSON.stringify(prepared_opts)));
      }
      create_request(opts) {
        const req = {
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${this.api_key}`
          },
          method: "POST"
        };
        if (this.config.headers) {
          req.headers = { ...req.headers, ...this.config.headers };
        }
        if (this.config.api_key_header) {
          if (this.config.api_key_header !== "none") {
            req.headers[this.config.api_key_header] = this.api_key;
          }
          delete req.headers.Authorization;
        }
        const body = typeof this.env.actions?.prepare_request_body === "function" ? this.env.actions.prepare_request_body(opts) : { ...opts };
        req.body = JSON.stringify(typeof this.adapter?.prepare_request_body === "function" ? this.adapter.prepare_request_body(body) : body);
        return req;
      }
      async handle_streaming_request(request2, render) {
        return this.stream(request2);
      }
      async handle_non_streaming_request(request2, opts, render) {
        const resp_json = await this.request(request2);
        if (resp_json.error) {
          return this.handle_api_error(resp_json.error, render);
        }
        const tool_call = this.get_tool_call(resp_json);
        if (tool_call) {
          return this.handle_tool_call(tool_call, opts, render);
        }
        const message_content = this.get_message_content(resp_json);
        if (render) {
          this.done_handler(message_content);
        }
        return message_content;
      }
      handle_api_error(error, render) {
        console.error(error);
        if (render) {
          this.done_handler("*API Error. See console logs for details.*");
        }
        return "*API Error. See console logs for details.*";
      }
      async handle_tool_call(tool_call, opts, render) {
        if (this.env.chats?.current?.tool_choice) {
          this.env.chats.current.tool_choice = null;
        }
        const tool_name = this.get_tool_name(tool_call);
        const tool_call_content = this.get_tool_call_content(tool_call);
        const tools = opts.tools || [];
        const tool = tools.find((t) => t.function.name === tool_name);
        const tool_handler = this.get_tool_handler(tool_name);
        if (!tool_handler || !is_valid_tool_call(tool, tool_call_content)) {
          return this.handle_invalid_tool_call(tool_name, tool_call_content);
        }
        await this.add_tool_call_to_chat(tool_name, tool_call_content);
        const tool_output = await tool_handler(this.env, tool_call_content);
        if (tool_output) {
          await this.current.add_tool_output(tool_name, tool_output);
          this.current.tool_choice = "none";
          return this.complete({});
        }
      }
      handle_invalid_tool_call(tool_name, tool_call_content) {
        console.warn(`Tool ${tool_name} not found or invalid, returning tool_call_content`);
        console.log({ tool_call_content });
        return tool_call_content;
      }
      async add_tool_call_to_chat(tool_name, tool_call_content) {
        if (typeof this.current?.add_message === "function") {
          await this.current.add_message({
            role: "assistant",
            tool_calls: [{
              function: {
                name: tool_name,
                arguments: JSON.stringify(tool_call_content)
              }
            }]
          });
        }
      }
      handle_error(err, render) {
        console.error(err);
        if (render) {
          this.done_handler("*An error occurred. See console logs for details.*");
        }
        return "*An error occurred. See console logs for details.*";
      }
      // HANDLE TOOLS
      /**
       * Retrieves the tool handler function based on the tool name from the environment's actions.
       * This method can be overridden to use custom logic for handling tools.
       * 
       * @param {string} tool_name - The name of the tool for which the handler is to be retrieved.
       * @returns {Function} The handler function for the specified tool.
       */
      get_tool_handler(tool_name) {
        return this.env.actions?.actions?.[tool_name]?.handler;
      }
      /**
       * Extracts the tool call information from a JSON response. This method supports adapter-specific logic.
       * If no adapter method is provided, it defaults to the expected OpenAI JSON format.
       * 
       * @param {Object} json - The JSON response from which to extract the tool call.
       * @returns {Object} The first tool call found in the response.
       */
      get_tool_call(json) {
        if (typeof this.adapter?.get_tool_call === "function") return this.adapter.get_tool_call(json);
        return json.choices?.[0].message.tool_calls?.[0];
      }
      /**
       * Determines the tool name from a tool call object. Supports adapter-specific implementations.
       * Defaults to extracting the name directly from the tool call structure.
       * 
       * @param {Object} tool_call - The tool call object from which to extract the tool name.
       * @returns {string} The name of the tool.
       */
      get_tool_name(tool_call) {
        if (typeof this.adapter?.get_tool_name === "function") return this.adapter.get_tool_name(tool_call);
        return tool_call.function.name;
      }
      /**
       * Extracts the tool call content from a tool call object. Supports adapter-specific logic.
       * Defaults to parsing the 'arguments' field of the tool call function as JSON.
       * 
       * @param {Object} tool_call - The tool call object from which to extract the content.
       * @returns {Object} The parsed arguments of the tool call.
       */
      get_tool_call_content(tool_call) {
        if (typeof this.adapter?.get_tool_call_content === "function") return this.adapter.get_tool_call_content(tool_call);
        return JSON.parse(tool_call.function.arguments);
      }
      // HANDLE MESSAGES
      /**
       * Retrieves the message object from a JSON response. Supports adapter-specific implementations.
       * Defaults to handling both OpenAI and Ollama formats by checking for message structures in 'choices'.
       * 
       * @param {Object} json - The JSON response from which to extract the message.
       * @returns {Object} The message object extracted from the response.
       */
      get_message(json) {
        if (typeof this.adapter?.get_message === "function") return this.adapter.get_message(json);
        return json.choices?.[0].message || json.message;
      }
      /**
       * Extracts the content of a message from a JSON response. Supports adapter-specific implementations.
       * This method relies on `get_message` to first retrieve the message object.
       * 
       * @param {Object} json - The JSON response from which to extract the message content.
       * @returns {string} The content of the message.
       */
      get_message_content(json) {
        if (typeof this.adapter?.get_message_content === "function") return this.adapter.get_message_content(json);
        return this.get_message(json).content;
      }
      async request(req) {
        req.url = this.endpoint;
        req.throw = false;
        const resp = this._request_adapter ? await this._request_adapter(req) : await fetch(this.endpoint, req);
        console.log(resp);
        const resp_json = await this.get_resp_json(resp);
        console.log(resp_json);
        return resp_json;
      }
      async get_resp_json(resp) {
        return typeof resp.json === "function" ? await resp.json() : await resp.json;
      }
      get request_adapter() {
        return this._request_adapter;
      }
      async stream(req) {
        console.log("Streaming Request: ");
        console.log(req);
        const full_text = await new Promise((resolve, reject) => {
          try {
            this.active_stream = new SmartStreamer(this.endpoint_streaming, req);
            let curr_text = "";
            this.active_stream.addEventListener("message", (e) => {
              if (this.is_end_of_stream(e)) {
                this.stop_stream();
                return resolve(curr_text);
              }
              let text_chunk = this.get_text_chunk_from_stream(e);
              if (!text_chunk) return;
              curr_text += text_chunk;
              this.chunk_handler(text_chunk);
            });
            this.active_stream.addEventListener("readystatechange", (e) => {
              if (e.readyState >= 2) console.log("ReadyState: " + e.readyState);
            });
            this.active_stream.addEventListener("error", (e) => {
              console.error(e);
              this.done_handler("*API Error. See console logs for details.*");
              this.stop_stream();
              reject(e);
            });
            this.active_stream.stream();
          } catch (err) {
            console.error(err);
            this.stop_stream();
            reject(err);
          }
        });
        this.done_handler(full_text);
        return full_text;
      }
      get_text_chunk_from_stream(event) {
        if (typeof this.adapter?.get_text_chunk_from_stream === "function") return this.adapter.get_text_chunk_from_stream(event);
        let resp = null;
        let text_chunk = "";
        try {
          resp = JSON.parse(event.data);
          text_chunk = resp.choices[0].delta.content;
        } catch (err) {
          console.log(err);
          console.log(event.data);
          if (event.data.indexOf("}{") > -1) event.data = event.data.replace(/}{/g, "},{");
          resp = JSON.parse(`[${event.data}]`);
          resp.forEach((r) => {
            if (r.choices) text_chunk += r.choices[0].delta.content;
          });
        }
        return text_chunk;
      }
      is_end_of_stream(event) {
        if (typeof this.adapter?.is_end_of_stream === "function") return this.adapter.is_end_of_stream(event);
        return event.data === "[DONE]";
      }
      stop_stream() {
        if (this.active_stream) {
          this.active_stream.end();
          this.active_stream = null;
        }
      }
      done_handler(full_str) {
        if (typeof this.main.done_handler === "function") this.main.done_handler(full_str);
      }
      chunk_handler(text_chunk) {
        if (typeof this.main.chunk_handler === "function") this.main.chunk_handler(text_chunk);
      }
      async count_tokens(input) {
        if (typeof this.adapter?.count_tokens === "function") return await this.adapter.count_tokens(input);
        return this.estimate_tokens(input);
      }
      estimate_tokens(input) {
        if (typeof this.adapter?.estimate_tokens === "function") return this.adapter.estimate_tokens(input);
        if (typeof input === "object") input = JSON.stringify(input);
        return input.length / 4;
      }
      async test_api_key() {
        console.log(this.api_key);
        try {
          const request2 = {
            messages: [
              { role: "user", content: "Hello" }
            ],
            temperature: 0,
            max_tokens: 100,
            stream: false,
            n: 1
          };
          if (this.config.fetch_models) {
            request2.model = this.config.default_model;
          }
          const resp = await this.complete(request2, false);
          console.log(resp);
          if (!resp) return false;
          return true;
        } catch (err) {
          console.error(err);
          return false;
        }
      }
      async get_models() {
        if (!this.api_key) {
          console.warn(`No API key found for ${this.platform_key}. Cannot retrieve models.`);
          return [];
        }
        if (this.platforms[this.platform_key]?.fetch_models && typeof fetch_models[this.platform_key] === "function") {
          const models = await fetch_models[this.platform_key](this.api_key, this._request_adapter);
          if (models) {
            models.sort((a, b) => a.model_name.localeCompare(b.model_name));
            return models;
          } else console.error(`No models found for ${this.platform_key}`, models);
        }
        return [];
      }
      async get_base_model_config() {
        const models = await this.get_models();
        return models.find((m) => m.key === this.model_name);
      }
      // getters
      get api_key() {
        return this.config.api_key;
      }
      get current() {
        return this.env.chats?.current;
      }
      // use endpoint of combine protocol, hostname, port, and path
      get endpoint() {
        if (typeof this.adapter?.endpoint !== "undefined") return this.adapter.endpoint.replace("MODEL_NAME", this.model_name);
        return this.config.endpoint || this.config.protocol + "://" + this.config.hostname + (this.config.port ? ":" + this.config.port : "") + this.endpoint_path;
      }
      get endpoint_streaming() {
        if (typeof this.adapter?.endpoint_streaming !== "undefined") return this.adapter.endpoint_streaming.replace("MODEL_NAME", this.model_name);
        return this.config.endpoint_streaming || this.endpoint;
      }
      get endpoint_path() {
        return this.config.path.startsWith("/") ? this.config.path : "/" + this.config.path;
      }
      get max_input_tokens() {
        return this.config.max_input_tokens;
      }
      get max_output_tokens() {
        return this.config.max_output_tokens;
      }
      get model_name() {
        return this.config.model_name || this.config.default_model;
      }
      get multimodal() {
        return typeof this.adapter?.multimodal !== "undefined" ? this.adapter.multimodal : this.config.multimodal;
      }
    };
    exports2.SmartChatModel = SmartChatModel3;
  }
});

// ../jsbrains/smart-setting/ejs.min.cjs
var require_ejs_min2 = __commonJS({
  "../jsbrains/smart-setting/ejs.min.cjs"(exports2, module2) {
    (function(f) {
      if (typeof exports2 === "object" && typeof module2 !== "undefined") {
        module2.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.ejs = f();
      }
    })(function() {
      var define2, module3, exports3;
      return (/* @__PURE__ */ function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof require && require;
                if (!f && c) return c(i2, true);
                if (u) return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
          return o;
        }
        return r;
      }())({ 1: [function(require2, module4, exports4) {
        "use strict";
        var fs = require2("fs");
        var path = require2("path");
        var utils = require2("./utils");
        var scopeOptionWarned = false;
        var _VERSION_STRING = require2("../package.json").version;
        var _DEFAULT_OPEN_DELIMITER = "<";
        var _DEFAULT_CLOSE_DELIMITER = ">";
        var _DEFAULT_DELIMITER = "%";
        var _DEFAULT_LOCALS_NAME = "locals";
        var _NAME = "ejs";
        var _REGEX_STRING = "(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)";
        var _OPTS_PASSABLE_WITH_DATA = ["delimiter", "scope", "context", "debug", "compileDebug", "client", "_with", "rmWhitespace", "strict", "filename", "async"];
        var _OPTS_PASSABLE_WITH_DATA_EXPRESS = _OPTS_PASSABLE_WITH_DATA.concat("cache");
        var _BOM = /^\uFEFF/;
        var _JS_IDENTIFIER = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
        exports4.cache = utils.cache;
        exports4.fileLoader = fs.readFileSync;
        exports4.localsName = _DEFAULT_LOCALS_NAME;
        exports4.promiseImpl = new Function("return this;")().Promise;
        exports4.resolveInclude = function(name, filename, isDir) {
          var dirname = path.dirname;
          var extname = path.extname;
          var resolve = path.resolve;
          var includePath = resolve(isDir ? filename : dirname(filename), name);
          var ext = extname(name);
          if (!ext) {
            includePath += ".ejs";
          }
          return includePath;
        };
        function resolvePaths(name, paths) {
          var filePath;
          if (paths.some(function(v) {
            filePath = exports4.resolveInclude(name, v, true);
            return fs.existsSync(filePath);
          })) {
            return filePath;
          }
        }
        function getIncludePath(path2, options) {
          var includePath;
          var filePath;
          var views = options.views;
          var match = /^[A-Za-z]+:\\|^\//.exec(path2);
          if (match && match.length) {
            path2 = path2.replace(/^\/*/, "");
            if (Array.isArray(options.root)) {
              includePath = resolvePaths(path2, options.root);
            } else {
              includePath = exports4.resolveInclude(path2, options.root || "/", true);
            }
          } else {
            if (options.filename) {
              filePath = exports4.resolveInclude(path2, options.filename);
              if (fs.existsSync(filePath)) {
                includePath = filePath;
              }
            }
            if (!includePath && Array.isArray(views)) {
              includePath = resolvePaths(path2, views);
            }
            if (!includePath && typeof options.includer !== "function") {
              throw new Error('Could not find the include file "' + options.escapeFunction(path2) + '"');
            }
          }
          return includePath;
        }
        function handleCache(options, template) {
          var func;
          var filename = options.filename;
          var hasTemplate = arguments.length > 1;
          if (options.cache) {
            if (!filename) {
              throw new Error("cache option requires a filename");
            }
            func = exports4.cache.get(filename);
            if (func) {
              return func;
            }
            if (!hasTemplate) {
              template = fileLoader(filename).toString().replace(_BOM, "");
            }
          } else if (!hasTemplate) {
            if (!filename) {
              throw new Error("Internal EJS error: no file name or template provided");
            }
            template = fileLoader(filename).toString().replace(_BOM, "");
          }
          func = exports4.compile(template, options);
          if (options.cache) {
            exports4.cache.set(filename, func);
          }
          return func;
        }
        function tryHandleCache(options, data, cb) {
          var result;
          if (!cb) {
            if (typeof exports4.promiseImpl == "function") {
              return new exports4.promiseImpl(function(resolve, reject) {
                try {
                  result = handleCache(options)(data);
                  resolve(result);
                } catch (err) {
                  reject(err);
                }
              });
            } else {
              throw new Error("Please provide a callback function");
            }
          } else {
            try {
              result = handleCache(options)(data);
            } catch (err) {
              return cb(err);
            }
            cb(null, result);
          }
        }
        function fileLoader(filePath) {
          return exports4.fileLoader(filePath);
        }
        function includeFile(path2, options) {
          var opts = utils.shallowCopy(utils.createNullProtoObjWherePossible(), options);
          opts.filename = getIncludePath(path2, opts);
          if (typeof options.includer === "function") {
            var includerResult = options.includer(path2, opts.filename);
            if (includerResult) {
              if (includerResult.filename) {
                opts.filename = includerResult.filename;
              }
              if (includerResult.template) {
                return handleCache(opts, includerResult.template);
              }
            }
          }
          return handleCache(opts);
        }
        function rethrow(err, str, flnm, lineno, esc) {
          var lines = str.split("\n");
          var start = Math.max(lineno - 3, 0);
          var end = Math.min(lines.length, lineno + 3);
          var filename = esc(flnm);
          var context = lines.slice(start, end).map(function(line, i) {
            var curr = i + start + 1;
            return (curr == lineno ? " >> " : "    ") + curr + "| " + line;
          }).join("\n");
          err.path = filename;
          err.message = (filename || "ejs") + ":" + lineno + "\n" + context + "\n\n" + err.message;
          throw err;
        }
        function stripSemi(str) {
          return str.replace(/;(\s*$)/, "$1");
        }
        exports4.compile = function compile(template, opts) {
          var templ;
          if (opts && opts.scope) {
            if (!scopeOptionWarned) {
              console.warn("`scope` option is deprecated and will be removed in EJS 3");
              scopeOptionWarned = true;
            }
            if (!opts.context) {
              opts.context = opts.scope;
            }
            delete opts.scope;
          }
          templ = new Template(template, opts);
          return templ.compile();
        };
        exports4.render = function(template, d, o) {
          var data = d || utils.createNullProtoObjWherePossible();
          var opts = o || utils.createNullProtoObjWherePossible();
          if (arguments.length == 2) {
            utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);
          }
          return handleCache(opts, template)(data);
        };
        exports4.renderFile = function() {
          var args = Array.prototype.slice.call(arguments);
          var filename = args.shift();
          var cb;
          var opts = { filename };
          var data;
          var viewOpts;
          if (typeof arguments[arguments.length - 1] == "function") {
            cb = args.pop();
          }
          if (args.length) {
            data = args.shift();
            if (args.length) {
              utils.shallowCopy(opts, args.pop());
            } else {
              if (data.settings) {
                if (data.settings.views) {
                  opts.views = data.settings.views;
                }
                if (data.settings["view cache"]) {
                  opts.cache = true;
                }
                viewOpts = data.settings["view options"];
                if (viewOpts) {
                  utils.shallowCopy(opts, viewOpts);
                }
              }
              utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);
            }
            opts.filename = filename;
          } else {
            data = utils.createNullProtoObjWherePossible();
          }
          return tryHandleCache(opts, data, cb);
        };
        exports4.Template = Template;
        exports4.clearCache = function() {
          exports4.cache.reset();
        };
        function Template(text, opts) {
          opts = opts || utils.createNullProtoObjWherePossible();
          var options = utils.createNullProtoObjWherePossible();
          this.templateText = text;
          this.mode = null;
          this.truncate = false;
          this.currentLine = 1;
          this.source = "";
          options.client = opts.client || false;
          options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;
          options.compileDebug = opts.compileDebug !== false;
          options.debug = !!opts.debug;
          options.filename = opts.filename;
          options.openDelimiter = opts.openDelimiter || exports4.openDelimiter || _DEFAULT_OPEN_DELIMITER;
          options.closeDelimiter = opts.closeDelimiter || exports4.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;
          options.delimiter = opts.delimiter || exports4.delimiter || _DEFAULT_DELIMITER;
          options.strict = opts.strict || false;
          options.context = opts.context;
          options.cache = opts.cache || false;
          options.rmWhitespace = opts.rmWhitespace;
          options.root = opts.root;
          options.includer = opts.includer;
          options.outputFunctionName = opts.outputFunctionName;
          options.localsName = opts.localsName || exports4.localsName || _DEFAULT_LOCALS_NAME;
          options.views = opts.views;
          options.async = opts.async;
          options.destructuredLocals = opts.destructuredLocals;
          options.legacyInclude = typeof opts.legacyInclude != "undefined" ? !!opts.legacyInclude : true;
          if (options.strict) {
            options._with = false;
          } else {
            options._with = typeof opts._with != "undefined" ? opts._with : true;
          }
          this.opts = options;
          this.regex = this.createRegex();
        }
        Template.modes = { EVAL: "eval", ESCAPED: "escaped", RAW: "raw", COMMENT: "comment", LITERAL: "literal" };
        Template.prototype = { createRegex: function() {
          var str = _REGEX_STRING;
          var delim = utils.escapeRegExpChars(this.opts.delimiter);
          var open = utils.escapeRegExpChars(this.opts.openDelimiter);
          var close = utils.escapeRegExpChars(this.opts.closeDelimiter);
          str = str.replace(/%/g, delim).replace(/</g, open).replace(/>/g, close);
          return new RegExp(str);
        }, compile: function() {
          var src;
          var fn;
          var opts = this.opts;
          var prepended = "";
          var appended = "";
          var escapeFn = opts.escapeFunction;
          var ctor;
          var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : "undefined";
          if (!this.source) {
            this.generateSource();
            prepended += '  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n';
            if (opts.outputFunctionName) {
              if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) {
                throw new Error("outputFunctionName is not a valid JS identifier.");
              }
              prepended += "  var " + opts.outputFunctionName + " = __append;\n";
            }
            if (opts.localsName && !_JS_IDENTIFIER.test(opts.localsName)) {
              throw new Error("localsName is not a valid JS identifier.");
            }
            if (opts.destructuredLocals && opts.destructuredLocals.length) {
              var destructuring = "  var __locals = (" + opts.localsName + " || {}),\n";
              for (var i = 0; i < opts.destructuredLocals.length; i++) {
                var name = opts.destructuredLocals[i];
                if (!_JS_IDENTIFIER.test(name)) {
                  throw new Error("destructuredLocals[" + i + "] is not a valid JS identifier.");
                }
                if (i > 0) {
                  destructuring += ",\n  ";
                }
                destructuring += name + " = __locals." + name;
              }
              prepended += destructuring + ";\n";
            }
            if (opts._with !== false) {
              prepended += "  with (" + opts.localsName + " || {}) {\n";
              appended += "  }\n";
            }
            appended += "  return __output;\n";
            this.source = prepended + this.source + appended;
          }
          if (opts.compileDebug) {
            src = "var __line = 1\n  , __lines = " + JSON.stringify(this.templateText) + "\n  , __filename = " + sanitizedFilename + ";\ntry {\n" + this.source + "} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n";
          } else {
            src = this.source;
          }
          if (opts.client) {
            src = "escapeFn = escapeFn || " + escapeFn.toString() + ";\n" + src;
            if (opts.compileDebug) {
              src = "rethrow = rethrow || " + rethrow.toString() + ";\n" + src;
            }
          }
          if (opts.strict) {
            src = '"use strict";\n' + src;
          }
          if (opts.debug) {
            console.log(src);
          }
          if (opts.compileDebug && opts.filename) {
            src = src + "\n//# sourceURL=" + sanitizedFilename + "\n";
          }
          try {
            if (opts.async) {
              try {
                ctor = new Function("return (async function(){}).constructor;")();
              } catch (e) {
                if (e instanceof SyntaxError) {
                  throw new Error("This environment does not support async/await");
                } else {
                  throw e;
                }
              }
            } else {
              ctor = Function;
            }
            fn = new ctor(opts.localsName + ", escapeFn, include, rethrow", src);
          } catch (e) {
            if (e instanceof SyntaxError) {
              if (opts.filename) {
                e.message += " in " + opts.filename;
              }
              e.message += " while compiling ejs\n\n";
              e.message += "If the above error is not helpful, you may want to try EJS-Lint:\n";
              e.message += "https://github.com/RyanZim/EJS-Lint";
              if (!opts.async) {
                e.message += "\n";
                e.message += "Or, if you meant to create an async function, pass `async: true` as an option.";
              }
            }
            throw e;
          }
          var returnedFn = opts.client ? fn : function anonymous(data) {
            var include = function(path2, includeData) {
              var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data);
              if (includeData) {
                d = utils.shallowCopy(d, includeData);
              }
              return includeFile(path2, opts)(d);
            };
            return fn.apply(opts.context, [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]);
          };
          if (opts.filename && typeof Object.defineProperty === "function") {
            var filename = opts.filename;
            var basename = path.basename(filename, path.extname(filename));
            try {
              Object.defineProperty(returnedFn, "name", { value: basename, writable: false, enumerable: false, configurable: true });
            } catch (e) {
            }
          }
          return returnedFn;
        }, generateSource: function() {
          var opts = this.opts;
          if (opts.rmWhitespace) {
            this.templateText = this.templateText.replace(/[\r\n]+/g, "\n").replace(/^\s+|\s+$/gm, "");
          }
          this.templateText = this.templateText.replace(/[ \t]*<%_/gm, "<%_").replace(/_%>[ \t]*/gm, "_%>");
          var self2 = this;
          var matches = this.parseTemplateText();
          var d = this.opts.delimiter;
          var o = this.opts.openDelimiter;
          var c = this.opts.closeDelimiter;
          if (matches && matches.length) {
            matches.forEach(function(line, index) {
              var closing;
              if (line.indexOf(o + d) === 0 && line.indexOf(o + d + d) !== 0) {
                closing = matches[index + 2];
                if (!(closing == d + c || closing == "-" + d + c || closing == "_" + d + c)) {
                  throw new Error('Could not find matching close tag for "' + line + '".');
                }
              }
              self2.scanLine(line);
            });
          }
        }, parseTemplateText: function() {
          var str = this.templateText;
          var pat = this.regex;
          var result = pat.exec(str);
          var arr = [];
          var firstPos;
          while (result) {
            firstPos = result.index;
            if (firstPos !== 0) {
              arr.push(str.substring(0, firstPos));
              str = str.slice(firstPos);
            }
            arr.push(result[0]);
            str = str.slice(result[0].length);
            result = pat.exec(str);
          }
          if (str) {
            arr.push(str);
          }
          return arr;
        }, _addOutput: function(line) {
          if (this.truncate) {
            line = line.replace(/^(?:\r\n|\r|\n)/, "");
            this.truncate = false;
          }
          if (!line) {
            return line;
          }
          line = line.replace(/\\/g, "\\\\");
          line = line.replace(/\n/g, "\\n");
          line = line.replace(/\r/g, "\\r");
          line = line.replace(/"/g, '\\"');
          this.source += '    ; __append("' + line + '")\n';
        }, scanLine: function(line) {
          var self2 = this;
          var d = this.opts.delimiter;
          var o = this.opts.openDelimiter;
          var c = this.opts.closeDelimiter;
          var newLineCount = 0;
          newLineCount = line.split("\n").length - 1;
          switch (line) {
            case o + d:
            case o + d + "_":
              this.mode = Template.modes.EVAL;
              break;
            case o + d + "=":
              this.mode = Template.modes.ESCAPED;
              break;
            case o + d + "-":
              this.mode = Template.modes.RAW;
              break;
            case o + d + "#":
              this.mode = Template.modes.COMMENT;
              break;
            case o + d + d:
              this.mode = Template.modes.LITERAL;
              this.source += '    ; __append("' + line.replace(o + d + d, o + d) + '")\n';
              break;
            case d + d + c:
              this.mode = Template.modes.LITERAL;
              this.source += '    ; __append("' + line.replace(d + d + c, d + c) + '")\n';
              break;
            case d + c:
            case "-" + d + c:
            case "_" + d + c:
              if (this.mode == Template.modes.LITERAL) {
                this._addOutput(line);
              }
              this.mode = null;
              this.truncate = line.indexOf("-") === 0 || line.indexOf("_") === 0;
              break;
            default:
              if (this.mode) {
                switch (this.mode) {
                  case Template.modes.EVAL:
                  case Template.modes.ESCAPED:
                  case Template.modes.RAW:
                    if (line.lastIndexOf("//") > line.lastIndexOf("\n")) {
                      line += "\n";
                    }
                }
                switch (this.mode) {
                  case Template.modes.EVAL:
                    this.source += "    ; " + line + "\n";
                    break;
                  case Template.modes.ESCAPED:
                    this.source += "    ; __append(escapeFn(" + stripSemi(line) + "))\n";
                    break;
                  case Template.modes.RAW:
                    this.source += "    ; __append(" + stripSemi(line) + ")\n";
                    break;
                  case Template.modes.COMMENT:
                    break;
                  case Template.modes.LITERAL:
                    this._addOutput(line);
                    break;
                }
              } else {
                this._addOutput(line);
              }
          }
          if (self2.opts.compileDebug && newLineCount) {
            this.currentLine += newLineCount;
            this.source += "    ; __line = " + this.currentLine + "\n";
          }
        } };
        exports4.escapeXML = utils.escapeXML;
        exports4.__express = exports4.renderFile;
        exports4.VERSION = _VERSION_STRING;
        exports4.name = _NAME;
        if (typeof window != "undefined") {
          window.ejs = exports4;
        }
      }, { "../package.json": 6, "./utils": 2, fs: 3, path: 4 }], 2: [function(require2, module4, exports4) {
        "use strict";
        var regExpChars = /[|\\{}()[\]^$+*?.]/g;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var hasOwn = function(obj, key) {
          return hasOwnProperty.apply(obj, [key]);
        };
        exports4.escapeRegExpChars = function(string) {
          if (!string) {
            return "";
          }
          return String(string).replace(regExpChars, "\\$&");
        };
        var _ENCODE_HTML_RULES = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&#34;", "'": "&#39;" };
        var _MATCH_HTML = /[&<>'"]/g;
        function encode_char(c) {
          return _ENCODE_HTML_RULES[c] || c;
        }
        var escapeFuncStr = `var _ENCODE_HTML_RULES = {
      "&": "&amp;"
    , "<": "&lt;"
    , ">": "&gt;"
    , '"': "&#34;"
    , "'": "&#39;"
    }
  , _MATCH_HTML = /[&<>'"]/g;
function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
};
`;
        exports4.escapeXML = function(markup) {
          return markup == void 0 ? "" : String(markup).replace(_MATCH_HTML, encode_char);
        };
        function escapeXMLToString() {
          return Function.prototype.toString.call(this) + ";\n" + escapeFuncStr;
        }
        try {
          if (typeof Object.defineProperty === "function") {
            Object.defineProperty(exports4.escapeXML, "toString", { value: escapeXMLToString });
          } else {
            exports4.escapeXML.toString = escapeXMLToString;
          }
        } catch (err) {
          console.warn("Unable to set escapeXML.toString (is the Function prototype frozen?)");
        }
        exports4.shallowCopy = function(to, from) {
          from = from || {};
          if (to !== null && to !== void 0) {
            for (var p in from) {
              if (!hasOwn(from, p)) {
                continue;
              }
              if (p === "__proto__" || p === "constructor") {
                continue;
              }
              to[p] = from[p];
            }
          }
          return to;
        };
        exports4.shallowCopyFromList = function(to, from, list) {
          list = list || [];
          from = from || {};
          if (to !== null && to !== void 0) {
            for (var i = 0; i < list.length; i++) {
              var p = list[i];
              if (typeof from[p] != "undefined") {
                if (!hasOwn(from, p)) {
                  continue;
                }
                if (p === "__proto__" || p === "constructor") {
                  continue;
                }
                to[p] = from[p];
              }
            }
          }
          return to;
        };
        exports4.cache = { _data: {}, set: function(key, val) {
          this._data[key] = val;
        }, get: function(key) {
          return this._data[key];
        }, remove: function(key) {
          delete this._data[key];
        }, reset: function() {
          this._data = {};
        } };
        exports4.hyphenToCamel = function(str) {
          return str.replace(/-[a-z]/g, function(match) {
            return match[1].toUpperCase();
          });
        };
        exports4.createNullProtoObjWherePossible = function() {
          if (typeof Object.create == "function") {
            return function() {
              return /* @__PURE__ */ Object.create(null);
            };
          }
          if (!({ __proto__: null } instanceof Object)) {
            return function() {
              return { __proto__: null };
            };
          }
          return function() {
            return {};
          };
        }();
      }, {}], 3: [function(require2, module4, exports4) {
      }, {}], 4: [function(require2, module4, exports4) {
        (function(process) {
          function normalizeArray(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up--; up) {
                parts.unshift("..");
              }
            }
            return parts;
          }
          exports4.resolve = function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : process.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                continue;
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          };
          exports4.normalize = function(path) {
            var isAbsolute = exports4.isAbsolute(path), trailingSlash = substr(path, -1) === "/";
            path = normalizeArray(filter(path.split("/"), function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          };
          exports4.isAbsolute = function(path) {
            return path.charAt(0) === "/";
          };
          exports4.join = function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return exports4.normalize(filter(paths, function(p, index) {
              if (typeof p !== "string") {
                throw new TypeError("Arguments to path.join must be strings");
              }
              return p;
            }).join("/"));
          };
          exports4.relative = function(from, to) {
            from = exports4.resolve(from).substr(1);
            to = exports4.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "") break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "") break;
              }
              if (start > end) return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          };
          exports4.sep = "/";
          exports4.delimiter = ":";
          exports4.dirname = function(path) {
            if (typeof path !== "string") path = path + "";
            if (path.length === 0) return ".";
            var code = path.charCodeAt(0);
            var hasRoot = code === 47;
            var end = -1;
            var matchedSlash = true;
            for (var i = path.length - 1; i >= 1; --i) {
              code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  end = i;
                  break;
                }
              } else {
                matchedSlash = false;
              }
            }
            if (end === -1) return hasRoot ? "/" : ".";
            if (hasRoot && end === 1) {
              return "/";
            }
            return path.slice(0, end);
          };
          function basename(path) {
            if (typeof path !== "string") path = path + "";
            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1) return "";
            return path.slice(start, end);
          }
          exports4.basename = function(path, ext) {
            var f = basename(path);
            if (ext && f.substr(-1 * ext.length) === ext) {
              f = f.substr(0, f.length - ext.length);
            }
            return f;
          };
          exports4.extname = function(path) {
            if (typeof path !== "string") path = path + "";
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var preDotState = 0;
            for (var i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }
                continue;
              }
              if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
              if (code === 46) {
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
              } else if (startDot !== -1) {
                preDotState = -1;
              }
            }
            if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              return "";
            }
            return path.slice(startDot, end);
          };
          function filter(xs, f) {
            if (xs.filter) return xs.filter(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              if (f(xs[i], i, xs)) res.push(xs[i]);
            }
            return res;
          }
          var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
            return str.substr(start, len);
          } : function(str, start, len) {
            if (start < 0) start = str.length + start;
            return str.substr(start, len);
          };
        }).call(this, require2("_process"));
      }, { _process: 5 }], 5: [function(require2, module4, exports4) {
        var process = module4.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {
        }
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name) {
          return [];
        };
        process.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      }, {}], 6: [function(require2, module4, exports4) {
        module4.exports = { name: "ejs", description: "Embedded JavaScript templates", keywords: ["template", "engine", "ejs"], version: "3.1.9", author: "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)", license: "Apache-2.0", bin: { ejs: "./bin/cli.js" }, main: "./lib/ejs.js", jsdelivr: "ejs.min.js", unpkg: "ejs.min.js", repository: { type: "git", url: "git://github.com/mde/ejs.git" }, bugs: "https://github.com/mde/ejs/issues", homepage: "https://github.com/mde/ejs", dependencies: { jake: "^10.8.5" }, devDependencies: { browserify: "^16.5.1", eslint: "^6.8.0", "git-directory-deploy": "^1.5.1", jsdoc: "^4.0.2", "lru-cache": "^4.0.1", mocha: "^10.2.0", "uglify-js": "^3.3.16" }, engines: { node: ">=0.10.0" }, scripts: { test: "mocha -u tdd" } };
      }, {}] }, {}, [1])(1);
    });
  }
});

// main.js
var main_exports = {};
__export(main_exports, {
  default: () => SmartTemplatesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = __toESM(require("obsidian"), 1);

// ../jsbrains/smart-templates/smart_templates.js
var import_ejs_min = __toESM(require_ejs_min(), 1);
var import_smart_chat_model = __toESM(require_smart_chat_model(), 1);
var SmartTemplates = class _SmartTemplates {
  constructor(env = {}, opts = {}) {
    this.env = env;
    this.opts = opts;
    this.adapter = opts.adapter || null;
    this.file_type_adapters = {};
    if (opts.file_type_adapters) {
      for (const adapter_class of opts.file_type_adapters) {
        const adapter = new adapter_class(this);
        for (const file_type of adapter.file_types) {
          this.file_type_adapters[file_type] = adapter;
        }
      }
    }
    if (opts.read_adapter) this.read_adapter = opts.read_adapter;
    else throw new Error("opts.read_adapter is required (ex. async (path) => await fs.promises.readFile(path, 'utf8'))");
    this._templates = {};
  }
  static async load(env, opts = {}) {
    env.smart_templates = new _SmartTemplates(env, opts);
    await env.smart_templates.init();
    return env.smart_templates;
  }
  async init() {
  }
  get request_adapter() {
    return this.opts.request_adapter || null;
  }
  get settings() {
    return this.env.settings;
  }
  get var_prompts() {
    return this.settings.smart_templates?.var_prompts || {};
  }
  get api_key() {
    return this.settings.smart_templates?.api_key;
  }
  get file_types() {
    return [
      ...Object.keys(this.file_type_adapters),
      "ejs"
    ];
  }
  get_adapter_by(file_type) {
    return this.file_type_adapters[file_type];
  }
  // EJS template base syntax engine
  async get_template(template, opts = {}) {
    if (typeof template !== "string") throw new Error("Template must be a string");
    if (this._templates[template]) template = this._templates[template];
    const adapter = this.get_adapter_by(opts.file_type || template.split(".").pop());
    if (typeof adapter?.get_template === "function") return await adapter.get_template(template);
    if (!template.includes("\n") && this.file_types.includes(template.split(".").pop())) {
      template = await this.load_template(template);
    }
    if (typeof adapter?.convert_to_ejs === "function") {
      template = adapter.convert_to_ejs(template);
    }
    return template;
  }
  async load_template(pointer) {
    try {
      let template = await this.read_adapter(pointer);
      return template;
    } catch (error) {
      console.error(`Error loading template from ${pointer}:`, error.message, error.stack);
      return "";
    }
  }
  // Get variables from EJS template
  async get_variables(pointer, opts = {}) {
    let variables = [];
    const file_type = opts.file_type || pointer.split(".").pop();
    const adapter = this.get_adapter_by(file_type);
    if (adapter && typeof adapter.get_variables === "function") {
      return await adapter.get_variables(pointer, opts);
    }
    const template = await this.get_template(pointer, opts);
    const regex = /<%[-_=]?\s*=?\s*([\w.]+(\[\w+])?)\s*[-_]?%>/g;
    let match;
    while ((match = regex.exec(template)) !== null) {
      const variable = match[1];
      const mainVariable = variable.split(/\[|\./)[0].trim();
      const prompt = this.var_prompts[mainVariable]?.prompt || null;
      variables.push({ name: mainVariable, prompt });
    }
    return variables;
  }
  async get_chatml_tools(variables, opts = {}) {
    const properties = variables.reduce((acc, variable) => {
      acc[variable.name] = { type: "string", description: variable.prompt || "TODO" };
      return acc;
    }, {});
    return {
      type: "function",
      function: {
        name: "generate_content",
        description: "Generate arguments based on the CONTEXT." + (opts.system_prompt ? ` ${opts.system_prompt}` : ""),
        parameters: {
          type: "object",
          properties,
          required: variables.map((variable) => variable.name)
        }
      }
    };
  }
  // Get view data using the function call output
  async get_view_data(output) {
    if (this.adapter && typeof this.adapter.get_view_data === "function") {
      return this.adapter.get_view_data(output);
    }
    return output;
  }
  // Render template with context and options
  async render(template, context, opts = {}) {
    const template_content = await this.get_template(template, opts);
    const variables = await this.get_variables(template, opts);
    const mergedContext = { context, ...opts };
    variables.forEach((variable) => {
      mergedContext[variable.name] = "EMPTY";
    });
    const functionCallRequest = {
      messages: [
        {
          role: "user",
          content: `---CONTEXT---
${context}
---END CONTEXT---`
        }
      ],
      tools: [
        await this.get_chatml_tools(variables, opts)
      ],
      tool_choice: {
        type: "function",
        function: {
          name: "generate_content"
        }
      },
      stream: false
    };
    if (opts.system_prompt) {
      functionCallRequest.messages[0].content += `
---IMPORTANT---
${opts.system_prompt}
---END IMPORTANT---`;
      functionCallRequest.messages.unshift({ role: "system", content: opts.system_prompt });
    }
    const chatModel = new import_smart_chat_model.SmartChatModel(this.env, this.chat_model_platform_key, this.model_config);
    if (this.request_adapter) chatModel._request_adapter = this.request_adapter;
    const replacementValues = await chatModel.complete(functionCallRequest);
    Object.entries(replacementValues).forEach(([key, value]) => {
      if (typeof value !== "string" && typeof value !== "number") {
        console.warn(`Replacement value is not a string or number: `, JSON.stringify(value, null, 2));
        if (Array.isArray(value)) {
          replacementValues[key] = value.join("\n");
        } else {
          replacementValues[key] = value ? JSON.stringify(value) : "";
        }
      }
    });
    Object.assign(mergedContext, replacementValues);
    return import_ejs_min.default.render(template_content, mergedContext);
  }
  get model_config() {
    if (this.env.smart_templates_plugin?.settings?.[this.chat_model_platform_key]) return this.env.smart_templates_plugin.settings[this.chat_model_platform_key];
    if (this.env.settings?.[this.chat_model_platform_key]) return this.env.settings[this.chat_model_platform_key];
    return { api_key: this.api_key };
  }
  get chat_model_platform_key() {
    if (this.env.smart_templates_plugin?.settings?.chat_model_platform_key) return this.env.smart_templates_plugin.settings.chat_model_platform_key;
    if (this.env.settings?.smart_templates?.chat_model_platform_key) return this.env.settings.smart_templates.chat_model_platform_key;
    return this.env.settings?.chat_model_platform_key || "openai";
  }
  add_template(path) {
    const file_name = path.split("/").pop().split(".").shift();
    this._templates[file_name] = path;
  }
  get templates() {
    return Object.keys(this._templates);
  }
};

// ../jsbrains/smart-templates/adapters/markdown.js
var MarkdownAdapter = class {
  constructor(main) {
    this.main = main;
  }
  get file_types() {
    return ["md"];
  }
  convert_to_ejs(template) {
    return convert_to_ejs(template);
  }
  async get_variables(template) {
    if (!template.includes("\n") && this.file_types.includes(template.split(".").pop())) {
      template = await this.main.load_template(template);
    }
    const variables = [];
    const regex = /{{\s*([^}]+)\s*}}/gi;
    const matches = template.match(regex);
    var i = 1;
    matches?.forEach((match, index) => {
      if (match.includes('"')) {
        variables.push({
          name: `var_${i++}`,
          prompt: match.replace(/{{\s*"([^"]+)"\s*}}/g, "$1").trim(),
          inline: true
        });
      } else {
        let name = match.replace(/{{\s*=?\s*([\w\s.-]+(\[\w+])?)\s*}}/g, "$1").trim();
        const prompt_key = name.replace(/[-\s]/g, "_");
        const prompt = (this.main.var_prompts[prompt_key]?.prompt || name + " prompt").trim();
        variables.push({ name: prompt_key, prompt });
      }
    });
    return variables;
  }
};
function convert_to_ejs(content) {
  const regex = /{{\s*"([^"]+)"\s*}}/g;
  const matches = content.match(regex);
  matches?.forEach((match, index) => {
    content = content.replace(match, `<%- var_${index + 1} %>`);
  });
  content = content.replace(/{{\s*([\w\s-]+)\s*}}/g, (match, p1) => `<%- ${p1.trim().replace(/[\s-]+/g, "_")} %>`);
  return content;
}

// main.js
var import_smart_chat_model2 = __toESM(require_smart_chat_model(), 1);

// dist/views.json
var views_default = {
  README: '# Smart Templates for Obsidian\n\nSmart Templates allows you to create and use configurable templates utilizing Smart Environments.\n\nSmart Templates is a companion plugin to [Smart Connections](https://github.com/brianpetro/obsidian-smart-connections/), a plugin for Obsidian that implements a Smart Environment for utilizing AI to enhance your notes.\n\n## Features\n\nCreate and use customizable templates with dynamic variables.\n\n- **AI-Powered**: Leverage AI models to generate content based on your templates, variable prompts, and current context (note or highlighted text).\n- **Variable Prompts**: Define prompts for each variable for more control over content generation.\n- **Flexible Configuration**: Choose your preferred AI model platform.\n- **Manual Prompt Input**: Use `{{ "Your prompt here" }}` syntax for on-the-fly custom prompts within templates.\n- **EJS Syntax Support**: Utilize EJS syntax for more advanced template logic and formatting.\n\n*More features coming soon...*:\n- Integration with [Smart Memos](https://github.com/Mossy1022/Smart-Memos)\n- Integration with Smart Connections to retrieve additional context\n- Integration with [Smart Connections Visualizer](https://github.com/Mossy1022/Smart-Connections-Visualizer) for visual selection of nodes to use as context\n\n## Installation\n\nCurrently in beta. Requires installing manually or via BRAT.\n\n**Smart Connections Supporters**: install using the "Easy Install" button in the early-release (version `2.2`) plugin settings.\n\n## Usage\n\n1. Set up your preferred AI model platform in the plugin settings.\n2. Create smart templates in the designated templates folder.\n3. Use the command palette to run your smart templates on your notes or selections.\n\n## Using Templates\n- A command is created for each template in the templates folder.\n- The command is run on the current note or highlighted selection (if any).\n- The template is rendered and the resulting content is inserted at the current cursor location.\n\n## Creating Templates\n\n1. Navigate to your designated templates folder.\n2. Create a new Markdown file for your template.\n3. Use special syntax to define dynamic parts of your template:\n   - `{{ variable_name }}`: Simple bracket syntax for predefined variables\n   - `{{ "Your custom prompt here" }}`: Manual prompt input syntax\n   - `<%- ... %>`: EJS syntax for advanced logic and formatting\n\nExample template:\n```markdown\n# Default Smart Template\n\n### Summary\n{{ summary }} <- Simple bracket syntax\n\n### Notes\n{{ notes }}\n\n### Chart\n<%- \'```mermaid\' %> <- EJS syntax is also available\n{{ mermaid }}\n<%- \'```\' %>\n```\n\n### Custom Prompt\n{{ "Your custom prompt here" }} <- Manual prompt input syntax\n\n## Settings\n![](./assets/Smart%20Templates%20Settings.png)\n\n### Model Platform\n\nChoose your preferred AI model platform (e.g., OpenAI) and enter your API key in the settings.\n\n### Templates Folder\n\nSpecify the folder where your smart templates will be stored.\n\n### Variable Prompts\n\nCustomize the prompts for template variables like summary, notes, and mermaid charts.\n\n## How it Works\n\n```mermaid\ngraph TD\n  A[Smart Template] -->|Contains| B(Variable Placeholders)\n  C[var_prompts] -->|Defines| D(Variable Prompts)\n  E[Current Context] -->|Provides| F(Content for Processing)\n  B --> G{Smart Templates Plugin}\n  D --> G\n  F --> G\n  G -->|Processes| H(AI Model)\n  H -->|Generates| I(Variable Content)\n  I --> J{Template Rendering}\n  A --> J\n  J -->|Produces| K[Final Output]\n```\n\n## About\n\nCreated by [\u{1F334} Brian](https://x.com/wfhbrian) as a companion plugin to [Smart Connections](https://github.com/brianpetro/obsidian-smart-connections/), a plugin for Obsidian that implements a Smart Environment for utilizing AI to enhance your notes.\n\n### Development\n\nUses [JSBrains](https://jsbrains.org/) to minimize dependencies and provide an easily adaptable architecture that supports new models and platforms.\n\n- [Smart Templates](https://github.com/brianpetro/jsbrains/tree/main/smart-templates)\n- [Smart Chat Model](https://github.com/brianpetro/jsbrains/tree/main/smart-chat-model)\n\n',
  smart_templates_model_settings: '  <div class="setting-component"\n    data-name="Model platform"\n    data-setting="chat_model_platform_key"\n    data-type="dropdown"\n    data-description="Select a model platform to use with Smart Chat."\n    data-callback="changed_smart_chat_platform"\n    <%- chat_platforms.map((platform, i) => `data-option-${i + 1}="${platform.key}|${platform.description}"`).join(\'\\n\') %>\n  ></div>\n  <% if(chat_platform?.fetch_models) { %>\n    <% if(settings[settings.chat_model_platform_key]?.api_key) { %>\n      <div class="setting-component"\n        data-name="Model name"\n        data-type="dropdown"\n        data-setting="<%= settings.chat_model_platform_key %>.model_name"\n        <%- platform_chat_models.map((model, i) => `data-option-${i}="${model.key}|${model.model_name} (${model.description})"`).join(\'\\n\') %>\n      ></div>\n    <% } %>\n    <% if(!platform_chat_models.length) { %>\n      <div class="setting-component"\n        data-name="Refresh models list"\n        data-type="button"\n        data-callback="changed_smart_chat_platform"\n      ></div>\n    <% } %>\n    <% if(can_import_from_smart_connections) { %>\n      <div class="setting-component"\n        data-name="Import model config from Smart Connections"\n        data-type="button"\n        data-callback="import_model_config_from_smart_connections"\n      ></div>\n    <% } %>\n    <div class="setting-component"\n      data-name="<%= chat_platform.description %> API key"\n      data-type="password"\n      data-setting="<%= settings.chat_model_platform_key %>.api_key"\n      <% if(chat_platform.signup_url) { %>\n        data-description="<a href=\'<%= chat_platform.signup_url %>\'>Get API Key</a> for <%= chat_platform.description %>."\n      <% } else { %>\n        data-description="API Key for <%= chat_platform.description %>."\n      <% } %>\n      data-placeholder="Enter an API key"\n      data-button="Save"\n      data-callback="changed_smart_chat_platform"\n    ></div>\n  <% } %>',
  smart_templates_settings: '<div id="smart-templates-settings">\n  <h2>AI model settings</h2>\n  <div class="smart-templates-model-settings">\n    <% if(model_settings) { %>\n      <%- model_settings %>\n    <% } else { %>\n      Loading model settings...\n    <% } %>\n  </div>\n  <h2>Smart Templates folder</h2>\n  <div class="setting-component"\n    data-name="Templates Folder"\n    data-setting="templates_folder"\n    data-type="text"\n  ></div>\n  <h2>Configure variable prompts</h2>\n  <div id="smart-templates-var-prompts">\n    <% var_prompts.forEach((var_prompt, i) => { %>\n      <% if(i === 0) { %>\n        <h3>Active</h3>\n      <% } else if(i > 0 && var_prompts[i-1].active !== var_prompt.active) { %>\n        <h3>Inactive</h3>\n      <% } %>\n      <div class="setting-component"\n        data-name="<%= var_prompt.name %>"\n        data-type="textarea"\n        data-setting="var_prompts.<%= var_prompt.name %>.prompt"\n        data-max-length="300"\n      ></div>\n      <% // if !var_prompt.active, add a button to remove it %>\n      <% if(!var_prompt.active) { %>\n        <div class="setting-component"\n          data-name="Remove"\n          data-value="<%= var_prompt.name %>"\n          data-type="button"\n          data-callback="remove_var_prompt"\n        ></div>\n      <% } %>\n    <% }) %>\n  </div>\n</div>'
};

// dist/templates.json
var templates_default = {
  overview: "### Summary\n{{ summary }}\n\n### Key Points\n{{ key points }}\n\n### Chart\n<%- '```mermaid' %>\n{{ mermaid }}\n<%- '```' %>\n",
  tags: '---\ntags_as_context: "true"\nsystem_prompt: Tags should be output in markdown bullet list format. Include the reason for each tag in parentheses.\n---\n##### recommended existing tags\n{{ TAGS EXISTING }}\n\n##### recommended new tags\n{{ TAGS NEW }}\n'
};

// templates/var_prompts.json
var var_prompts_default = {
  var_prompts: {
    summary: {
      prompt: "A summary paragraph about the content."
    },
    key_points: {
      prompt: "Concise notes about the content."
    },
    mermaid: {
      prompt: "Mermaid chart representation of the content. Ex. graph TD\nA --> B\nB --> C"
    },
    TAGS_EXISTING: {
      prompt: "List 3 existing tags that might be most relevant to the content."
    },
    TAGS_NEW: {
      prompt: "List 3 new tags that might be most relevant to the content."
    }
  }
};

// ../jsbrains/smart-environment/smart_env.js
var SmartEnv = class {
  constructor(main, opts = {}) {
    const main_name = camel_case_to_snake_case(main.constructor.name);
    this[main_name] = main;
    this.mains = [main_name];
    this.main = main;
    this.plugin = this.main;
    Object.assign(this, opts);
  }
  static create(main, opts = {}) {
    const global_ref = opts.global_ref || window || global;
    const existing_smart_env = global_ref.smart_env;
    if (existing_smart_env) {
      const main_name = camel_case_to_snake_case(main.constructor.name);
      existing_smart_env[main_name] = main;
      existing_smart_env.mains.push(main_name);
      Object.keys(opts).forEach((key) => {
        if (typeof opts[key] === "object") {
          if (Array.isArray(opts[key])) {
            existing_smart_env[key] = [
              ...existing_smart_env[key] || [],
              ...opts[key]
            ];
          } else if (opts[key] !== null) {
            existing_smart_env[key] = {
              ...existing_smart_env[key] || {},
              ...opts[key]
            };
          }
        } else {
          if (existing_smart_env[key]) console.warn(`SmartEnv: Overwriting existing property ${key} with ${opts[key]}`);
          existing_smart_env[key] = opts[key];
        }
      });
      global_ref.smart_env = existing_smart_env;
    } else {
      global_ref.smart_env = new this(main, opts);
    }
    main.env = global_ref.smart_env;
    return global_ref.smart_env;
  }
  get settings() {
    const settings = {};
    this.mains.forEach((main) => {
      if (!settings[main]) settings[main] = {};
      Object.keys(this[main].settings || {}).forEach((setting) => {
        settings[main][setting] = this[main].settings[setting];
      });
    });
    return settings;
  }
};
function camel_case_to_snake_case(str) {
  const result = str.replace(/([A-Z])/g, (match) => `_${match.toLowerCase()}`).replace(/^_/, "");
  return result;
}

// ../jsbrains/smart-setting/smart_settings.js
var import_ejs_min2 = __toESM(require_ejs_min2(), 1);
var SmartSettings = class {
  constructor(env, container, opts = { template_name: "smart_settings" }) {
    this.env = env;
    this.main = opts.main || this.env.plugin;
    this.plugin = this.main;
    this.container = container;
    if (typeof opts === "string") opts = { template_name: opts };
    this.template_name = opts.template_name;
    this.ejs = this.env.ejs || import_ejs_min2.default;
    this.views = opts.views || this.env.views;
    this.templates = this.env.templates;
  }
  get settings() {
    return this.main.settings;
  }
  set settings(settings) {
    this.main.settings = settings;
  }
  async render() {
    const view_data = typeof this.get_view_data === "function" ? await this.get_view_data() : this.view_data;
    this.render_template(view_data);
    this.render_components();
  }
  render_template(view_data = null) {
    if (!this.template) throw new Error(`Settings template not found.`);
    this.container.empty();
    this.container.innerHTML = this.ejs.render(this.template, view_data || this.view_data, { context: this });
  }
  async update(setting, value) {
    console.log("saving setting: " + setting);
    let settings = { ...this.settings };
    if (setting.includes(".")) {
      let parts = setting.split(".");
      let obj = settings;
      for (let i = 0; i < parts.length - 1; i++) {
        if (!obj[parts[i]]) obj[parts[i]] = {};
        obj = obj[parts[i]];
      }
      obj[parts[parts.length - 1]] = typeof value === "string" ? value.trim() : value;
    } else {
      settings[setting] = typeof value === "string" ? value.trim() : value;
    }
    this.settings = settings;
    await this.main.save_settings(true);
    console.log("saved settings");
  }
  render_components() {
    if (!this.main.obsidian.Setting) console.log("missing Obsidian");
    this.container.querySelectorAll(".setting-component").forEach((elm) => {
      const setting_elm = new this.main.obsidian.Setting(elm);
      if (elm.dataset.name) setting_elm.setName(elm.dataset.name);
      if (elm.dataset.description) setting_elm.descEl.innerHTML = elm.dataset.description;
      const setting = elm.dataset.setting;
      if (elm.dataset.type === "text") {
        setting_elm.addText((text) => {
          text.setPlaceholder(elm.dataset.placeholder || "");
          text.setValue(this.get_setting(setting));
          let debounceTimer;
          if (elm.dataset.button) {
            setting_elm.addButton((button) => {
              button.setButtonText(elm.dataset.button);
              button.onClick(async () => this.handle_on_change(setting, text.getValue(), elm));
            });
          } else {
            text.onChange(async (value) => {
              clearTimeout(debounceTimer);
              debounceTimer = setTimeout(() => this.handle_on_change(setting, value, elm), 2e3);
            });
          }
        });
      } else if (elm.dataset.type === "password") {
        setting_elm.addText((text) => {
          text.inputEl.type = "password";
          text.setPlaceholder(elm.dataset.placeholder || "");
          const setting_value = this.get_setting(setting);
          if (setting_value) text.setValue(setting_value);
          text.onChange(async (value) => this.handle_on_change(setting, value, elm));
        });
      } else if (elm.dataset.type === "number") {
        setting_elm.addText((number) => {
          number.inputEl.type = "number";
          number.setPlaceholder(elm.dataset.placeholder || "");
          number.inputEl.value = parseInt(this.get_setting(setting));
          number.inputEl.min = elm.dataset.min || 0;
          if (elm.dataset.max) number.inputEl.max = elm.dataset.max;
          let debounceTimer;
          number.onChange(async (value) => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => this.handle_on_change(setting, parseInt(value), elm), 2e3);
          });
        });
      } else if (elm.dataset.type === "dropdown") {
        setting_elm.addDropdown((dropdown) => {
          Object.entries(elm.dataset).filter(([k, v]) => k.startsWith("option")).forEach(([k, v]) => {
            const [value, name] = v.split("|");
            dropdown.addOption(value, name || value);
          });
          dropdown.onChange(async (value) => this.handle_on_change(setting, value, elm));
          dropdown.setValue(this.get_setting(setting));
        });
      } else if (elm.dataset.type === "button") {
        setting_elm.addButton((button) => {
          button.setButtonText(elm.dataset.btnText || elm.dataset.name);
          button.onClick(async () => {
            if (elm.dataset.confirm) {
              const confirmation_message = elm.dataset.confirm;
              if (!confirm(confirmation_message)) return;
            }
            if (elm.dataset.href) window.open(elm.dataset.href);
            if (elm.dataset.callback) this[elm.dataset.callback](setting, null, elm);
          });
        });
      } else if (elm.dataset.type === "toggle") {
        setting_elm.addToggle((toggle) => {
          toggle.setValue(this.get_setting(setting));
          toggle.onChange(async (value) => this.handle_on_change(setting, value, elm));
        });
      } else if (elm.dataset.type === "textarea") {
        setting_elm.addTextArea((textarea) => {
          textarea.setValue(this.get_setting(setting));
          textarea.onChange(async (value) => this.handle_on_change(setting, value, elm));
          if (elm.dataset.maxLength) textarea.inputEl.maxLength = elm.dataset.maxLength;
        });
      }
      if (elm.dataset.disabled) setting_elm.setDisabled(true);
    });
    console.log("rendered components");
  }
  async handle_on_change(setting, value, elm) {
    await this.update(setting, value);
    if (elm.dataset.callback) this[elm.dataset.callback](setting, value, elm);
  }
  get_setting(setting) {
    if (setting.includes(".")) {
      let parts = setting.split(".");
      let obj = this.settings;
      for (let part of parts.slice(0, -1)) {
        if (obj[part] === void 0) return this.plugin.constructor.defaults[setting];
        obj = obj[part];
      }
      return obj[parts[parts.length - 1]] ?? this.plugin.constructor.defaults[setting];
    } else {
      return this.settings[setting] ?? this.plugin.constructor.defaults[setting];
    }
  }
  // override in subclass (required)
  get template() {
    return "";
  }
  // ejs template string
  get view_data() {
    return {};
  }
  // object properties available in template
};

// main.js
var {
  addIcon,
  Keymap,
  MarkdownRenderer,
  Notice,
  Plugin,
  PluginSettingTab,
  request,
  requestUrl,
  Setting,
  TAbstractFile,
  TFile
} = import_obsidian.default;
var SmartTemplatesPlugin = class extends Plugin {
  async onload() {
    this.app.workspace.onLayoutReady(this.initialize.bind(this));
  }
  // initialize when layout is ready
  static get defaults() {
    return {
      openai: {},
      chat_model_platform_key: "openai",
      templates_folder: "smart-templates",
      var_prompts: {
        "summary": { prompt: "A brief summary paragraph." },
        "notes": { prompt: "Concise notes in list format." },
        "mermaid": { prompt: "A mermaid chart representing the content. Ex. graph TD\nA --> B\nB --> C" }
      }
    };
  }
  async initialize() {
    this.obsidian = import_obsidian.default;
    await this.load_settings();
    await this.ensure_templates_folder();
    await this.include_default_templates();
    SmartEnv.create(this, {
      global_ref: window
    });
    await this.load_smart_templates();
    this.addSettingTab(new SmartTemplatesSettingsTab(this.app, this));
    this.add_commands();
  }
  async load_smart_templates() {
    await SmartTemplates.load(this.env, {
      request_adapter: requestUrl,
      // use obsidian's requestUrl for requests
      read_adapter: this.app.vault.adapter.read.bind(this.app.vault.adapter),
      file_type_adapters: [
        MarkdownAdapter
      ]
    });
    await this.get_var_prompts_settings();
  }
  async load_settings() {
    this.settings = {
      ...this.constructor.defaults,
      ...await this.loadData()
    };
    this.settings = {
      ...this.settings,
      ...await this.load_var_prompts()
    };
  }
  async load_var_prompts() {
    const var_prompts_path = `${this.settings.templates_folder}/var_prompts.json`;
    try {
      if (await this.app.vault.adapter.exists(var_prompts_path)) {
        const var_prompts_file = await this.app.vault.adapter.read(var_prompts_path);
        if (var_prompts_file) {
          return JSON.parse(var_prompts_file);
        }
      }
    } catch (error) {
      console.error(`Error loading var_prompts from ${var_prompts_path}:`, error);
    }
    return {};
  }
  async save_settings(rerender = false) {
    await this.saveData(this.settings);
    await this.app.vault.adapter.write(
      `${this.settings.templates_folder}/var_prompts.json`,
      JSON.stringify({ var_prompts: this.settings.var_prompts }, null, 2)
    );
    await this.load_settings();
  }
  get_templates_from_folder(templates_folder_path) {
    const templates = [];
    const folder = this.app.vault.getFolderByPath(templates_folder_path);
    if (!folder) return templates;
    folder.children.forEach((file_or_folder) => {
      if (file_or_folder instanceof this.obsidian.TFile) {
        this.env.smart_templates.add_template(file_or_folder.path);
        templates.push(file_or_folder);
      } else if (file_or_folder instanceof this.obsidian.TFolder) {
        templates.push(...this.get_templates_from_folder(file_or_folder.path));
      }
    });
    return templates;
  }
  async get_var_prompts_settings() {
    this.active_template_vars = [];
    const templates = this.get_templates_from_folder(this.settings.templates_folder);
    for (const template of templates) {
      const template_vars = await this.env.smart_templates.get_variables(template.path);
      template_vars.filter(({ inline }) => !inline).forEach(({ name, prompt }) => {
        if (!this.settings.var_prompts) this.settings.var_prompts = {};
        if (!this.settings.var_prompts[name]) {
          this.settings.var_prompts[name] = { prompt };
        }
        this.active_template_vars.push(name);
      });
    }
  }
  // check if templates folder exists
  // if not, create it
  async ensure_templates_folder() {
    const templates_folder = this.app.vault.getFolderByPath(this.settings.templates_folder);
    if (!templates_folder) {
      await this.app.vault.createFolder(this.settings.templates_folder);
    }
  }
  async include_default_templates() {
    const default_templates_folder = this.app.vault.getFolderByPath(`${this.settings.templates_folder}/default`);
    if (!default_templates_folder) {
      await this.app.vault.createFolder(`${this.settings.templates_folder}/default`);
    }
    for (const [name, content] of Object.entries(templates_default)) {
      const default_template = this.app.vault.getFileByPath(`${this.settings.templates_folder}/default/${name}.md`);
      if (!default_template) {
        await this.app.vault.create(
          `${this.settings.templates_folder}/default/${name}.md`,
          content
        );
      }
    }
    const var_prompts_path = `${this.settings.templates_folder}/var_prompts.json`;
    if (!await this.app.vault.adapter.exists(var_prompts_path)) {
      await this.app.vault.adapter.write(var_prompts_path, "{}");
    }
    for (const [name, prompt] of Object.entries(var_prompts_default.var_prompts)) {
      if (!this.settings.var_prompts[name]) {
        this.settings.var_prompts[name] = prompt;
      }
    }
    await this.save_settings();
  }
  add_commands() {
    this.add_template_commands();
    this.addCommand({
      id: "update-commands",
      name: "Refresh commands (adds/removes templates from commands)",
      icon: "pencil_icon",
      editorCallback: this.add_template_commands.bind(this)
    });
  }
  add_template_commands() {
    const templates = this.get_templates_from_folder(this.settings.templates_folder);
    for (const template of templates) {
      if (template.name.endsWith(".json")) continue;
      this.addCommand({
        id: `${format_command_name(template.name)}`,
        name: `Generate: ${template.name.split(".md")?.[0] || template.name}`,
        icon: "pencil_icon",
        hotkeys: [],
        editorCallback: this.run_smart_template.bind(this, template.path)
      });
    }
  }
  async run_smart_template(template_path, editor, ctx) {
    const file = this.app.workspace.getActiveFile();
    const file_path = file.path;
    let context = file_path + "\n";
    if (editor.somethingSelected()) context = editor.getSelection();
    else context = editor.getValue();
    if (!context) return new Notice("[Smart Commands] No file or selection found");
    const template_tfile = this.app.vault.getFileByPath(template_path);
    const template_content = await this.app.vault.cachedRead(template_tfile);
    const template_frontmatter = parse_frontmatter(template_content);
    if (template_frontmatter?.tags_as_context) {
      context = `${this.tags_as_context}
${context}`;
    }
    const opts = {
      file_type: template_tfile.extension
    };
    if (template_frontmatter?.system_prompt) {
      opts.system_prompt = template_frontmatter.system_prompt;
    }
    const resp = await this.env.smart_templates.render(this.strip_frontmatter_context_config(template_content), context, opts);
    const lines = editor.getValue().split("\n");
    const last_line = lines[lines.length - 1];
    editor.setValue(editor.getValue() + "\n" + resp);
    const output_pos = { line: last_line, ch: 0 };
    editor.setCursor(output_pos);
    editor.scrollIntoView({ to: output_pos, from: output_pos }, true);
  }
  get context_frontmatter_index() {
    return ["tags_as_context", "system_prompt"];
  }
  get all_tags() {
    return Object.entries(this.app.metadataCache.getTags()).filter(([name]) => !this.context_frontmatter_index.includes(name)).map(([name, count]) => ({ name, count })).sort((a, b) => b.count - a.count);
  }
  get tags_as_context() {
    return `Existing tags in format "tag (frequency)":
` + this.all_tags.map((tag) => `${tag.name}${tag.count > 1 ? ` (${tag.count})` : ""}`).join("\n");
  }
  strip_frontmatter_context_config(template_content) {
    const regex_pattern = this.context_frontmatter_index.map((tag) => `^${tag}:.*\\n`).join("|");
    const dynamic_regex = new RegExp(regex_pattern, "gm");
    return template_content.replace(dynamic_regex, "").replace(/^---\n---/gm, "");
  }
};
var SmartTemplatesSettingsTab = class extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.config = plugin.settings;
  }
  display() {
    this.smart_settings = new SmartTemplatesSettings(
      this.plugin.env,
      this.containerEl,
      {
        main: this.plugin,
        // fixes not saving
        template_name: "smart_templates_settings",
        views: views_default
      }
    );
    return this.smart_settings.render();
  }
};
var SmartTemplatesSettings = class extends SmartSettings {
  get settings() {
    return this.env.smart_templates_plugin.settings;
  }
  set settings(settings) {
    this.env.smart_templates_plugin.settings = settings;
  }
  get model_config() {
    return this.settings[this.settings.chat_model_platform_key];
  }
  async get_view_data() {
    await this.env.smart_templates_plugin.get_var_prompts_settings();
    if (!this._model_settings) this.load_model_settings();
    const var_prompts = Object.entries(this.settings.var_prompts).map(([name, prompt]) => ({ name, prompt, active: this.env.smart_templates_plugin.active_template_vars.includes(name) })).sort((a, b) => a.name.localeCompare(b.name)).sort((a, b) => b.active - a.active);
    return {
      model_settings: this._model_settings || null,
      settings: this.settings,
      var_prompts
    };
  }
  async can_import_from_smart_connections() {
    if (!await this.main.app.vault.adapter.exists(`${this.main.app.vault.configDir}/plugins/smart-connections/data.json`)) return false;
    const config_file = await this.main.app.vault.adapter.read(`${this.main.app.vault.configDir}/plugins/smart-connections/data.json`);
    if (!config_file) return false;
    const config = JSON.parse(config_file);
    if (config[this.settings.chat_model_platform_key]?.api_key?.length && !this.settings[this.settings.chat_model_platform_key]?.api_key?.length) return true;
    return false;
  }
  async load_model_settings() {
    const chat_platforms = import_smart_chat_model2.SmartChatModel.platforms;
    const smart_chat_model = new import_smart_chat_model2.SmartChatModel(
      this.env,
      this.settings.chat_model_platform_key || "openai",
      this.model_config
    );
    smart_chat_model._request_adapter = requestUrl;
    const platform_chat_models = await smart_chat_model.get_models();
    this._model_settings = await this.ejs.render(
      this.views["smart_templates_model_settings"],
      {
        settings: this.settings,
        chat_platforms,
        platform_chat_models,
        chat_platform: smart_chat_model.platform,
        can_import_from_smart_connections: await this.can_import_from_smart_connections()
      }
    );
    this.render();
  }
  get template() {
    return this.views[this.template_name];
  }
  async changed_smart_chat_platform(render = true) {
    this._model_settings = null;
    this.env.smart_templates_plugin.load_smart_templates();
    if (render) this.render();
  }
  // import model config from smart-connections
  async import_model_config_from_smart_connections() {
    const config_file = await this.main.app.vault.adapter.read(`${this.main.app.vault.configDir}/plugins/smart-connections/data.json`);
    if (!config_file) return new Notice("[Smart Templates] No model config found in smart-connections");
    const config = JSON.parse(config_file);
    const settings = this.settings;
    if (config[this.settings.chat_model_platform_key]) settings[this.settings.chat_model_platform_key] = { ...config[this.settings.chat_model_platform_key] };
    this.settings = settings;
    await this.env.smart_templates_plugin.save_settings();
    this._model_settings = null;
    this.render();
  }
  async update(setting, value) {
    await super.update(setting, value);
  }
  async remove_var_prompt(setting, value, elm) {
    const var_prompt_name = elm.dataset.value;
    delete this.settings.var_prompts[var_prompt_name];
    await this.update("var_prompts", this.settings.var_prompts);
    this.render();
  }
};
function format_command_name(name) {
  return name.toLowerCase().replace(/[^a-z0-9]/ig, "-");
}
function parse_frontmatter(content) {
  const match = content.match(/^---\n([\s\S]+?)\n---/);
  if (match) {
    const frontmatter = match[1];
    const yaml_object = {};
    const lines = frontmatter.split("\n");
    for (const line of lines) {
      const [key, ...value_parts] = line.split(":");
      if (key && value_parts.length > 0) {
        const value = value_parts.join(":").trim();
        yaml_object[key.trim()] = value;
      }
    }
    return yaml_object;
  }
  return null;
}


/* nosourcemap */